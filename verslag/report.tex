\documentclass{report}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{titlesec}
\usepackage[tmargin=2.0cm, lmargin=4cm, rmargin=4cm]{geometry}
\usepackage{listings}             % Include the listings-package
\usepackage{textcomp}
\usepackage{listings}
%\usepackage{minted}      % (requires -shell-escape)
\usepackage{xcolor}
\usepackage{filecontents}
\usepackage{array}
\usepackage{multirow}
\usepackage{hyperref}
\usepackage{subfig}

\newcolumntype{L}{>{\centering\arraybackslash}m{3cm}}

% --- ugly internals for language definition ---
%
\makeatletter

% initialisation of user macros
\newcommand\PrologPredicateStyle{}
\newcommand\PrologVarStyle{}
\newcommand\PrologAnonymVarStyle{}
\newcommand\PrologAtomStyle{}
\newcommand\PrologOtherStyle{}
\newcommand\PrologCommentStyle{}

% useful switches (to keep track of context)
\newif\ifpredicate@prolog@
\newif\ifwithinparens@prolog@

% save definition of underscore for test
\lst@SaveOutputDef{`_}\underscore@prolog

% local variables
\newcount\currentchar@prolog

\newcommand\@testChar@prolog%
{%
  % if we're in processing mode...
  \ifnum\lst@mode=\lst@Pmode%
    \detectTypeAndHighlight@prolog%
  \else
    % ... or within parentheses
    \ifwithinparens@prolog@%
      \detectTypeAndHighlight@prolog%
    \fi
  \fi
  % Some housekeeping...
  \global\predicate@prolog@false%
}

% helper macros
\newcommand\detectTypeAndHighlight@prolog
{%
  % First, assume that we have an atom.
  \def\lst@thestyle{\PrologAtomStyle}%
  % Test whether we have a predicate and modify the style accordingly.
  \ifpredicate@prolog@%
    \def\lst@thestyle{\PrologPredicateStyle}%
  \else
    % Test whether we have a predicate and modify the style accordingly.
    \expandafter\splitfirstchar@prolog\expandafter{\the\lst@token}%
    % Check whether the identifier starts by an underscore.
    \expandafter\ifx\@testChar@prolog\underscore@prolog%
      % Check whether the identifier is '_' (anonymous variable)
      \ifnum\lst@length=1%
        \let\lst@thestyle\PrologAnonymVarStyle%
      \else
        \let\lst@thestyle\PrologVarStyle%
      \fi
    \else
      % Check whether the identifier starts by a capital letter.
      \currentchar@prolog=65
      \loop
        \expandafter\ifnum\expandafter`\@testChar@prolog=\currentchar@prolog%
          \let\lst@thestyle\PrologVarStyle%
          \let\iterate\relax
        \fi
        \advance \currentchar@prolog by 1
        \unless\ifnum\currentchar@prolog>90
      \repeat
    \fi
  \fi
}
\newcommand\splitfirstchar@prolog{}
\def\splitfirstchar@prolog#1{\@splitfirstchar@prolog#1\relax}
\newcommand\@splitfirstchar@prolog{}
\def\@splitfirstchar@prolog#1#2\relax{\def\@testChar@prolog{#1}}

% helper macro for () delimiters
\def\beginlstdelim#1#2%
{%
  \def\endlstdelim{\PrologOtherStyle #2\egroup}%
  {\PrologOtherStyle #1}%
  \global\predicate@prolog@false%
  \withinparens@prolog@true%
  \bgroup\aftergroup\endlstdelim%
}

% language name
\newcommand\lang@prolog{Prolog-pretty}
% ``normalised'' language name
\expandafter\lst@NormedDef\expandafter\normlang@prolog%
  \expandafter{\lang@prolog}

% language definition
\expandafter\expandafter\expandafter\lstdefinelanguage\expandafter%
{\lang@prolog}
{%
  language            = Prolog,
  keywords            = {},      % reset all preset keywords
  showstringspaces    = false,
  linewidth			  = 15.5cm,
  numbers			   =left, 
  alsoletter          = (,
  alsoother           = @\$,
  moredelim           = **[is][\beginlstdelim{(}{)}]{(}{)},
  MoreSelectCharTable =
    \lst@DefSaveDef{`(}\opparen@prolog{\global\predicate@prolog@true\opparen@prolog},
}

% Hooking into listings to test each ``identifier''
\newcommand\@ddedToOutput@prolog\relax
\lst@AddToHook{Output}{\@ddedToOutput@prolog}

\lst@AddToHook{PreInit}
{%
  \ifx\lst@language\normlang@prolog%
    \let\@ddedToOutput@prolog\@testChar@prolog%
  \fi
}

\lst@AddToHook{DeInit}{\renewcommand\@ddedToOutput@prolog{}}

\makeatother
%
% --- end of ugly internals ---


% --- definition of a custom style similar to that of Pygments ---
% custom colors
\definecolor{PrologPredicate}{RGB}{000,031,255}
\definecolor{PrologVar}      {RGB}{024,021,125}
\definecolor{PrologAnonymVar}{RGB}{000,127,000}
\definecolor{PrologAtom}     {RGB}{186,032,032}
\definecolor{PrologComment}  {RGB}{063,128,127}
\definecolor{PrologOther}    {RGB}{000,000,000}

% redefinition of user macros for Prolog style
\renewcommand\PrologPredicateStyle{\color{PrologPredicate}}
\renewcommand\PrologVarStyle{\color{PrologVar}}
\renewcommand\PrologAnonymVarStyle{\color{PrologAnonymVar}}
\renewcommand\PrologAtomStyle{\color{PrologAtom}}
\renewcommand\PrologCommentStyle{\itshape\color{PrologComment}}
\renewcommand\PrologOtherStyle{\color{PrologOther}}

% custom style definition 
\lstdefinestyle{Prolog-pygsty}
{
  language     = Prolog-pretty,
  upquote      = true,
  stringstyle  = \PrologAtomStyle,
  commentstyle = \PrologCommentStyle,
  literate     =
    {:-}{{\PrologOtherStyle :-}}2
    {,}{{\PrologOtherStyle ,}}1
    {.}{{\PrologOtherStyle .}}1
}

% global settings
\lstset
{
  captionpos = below,
  frame      = single,
  breaklines          = true,
  postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow\space}},
  columns    = fullflexible,
  basicstyle = \ttfamily,
}

%\titlespacing*{\chapter}{0pt}{-19pt}{18pt}

%\title{APLAI}
%\author{thierryderuyttere }
%\date{May 2017}
\newcommand{\mychapter}[2]{
    \setcounter{chapter}{#1}
    \setcounter{section}{0}
    \chapter*{#2}
    \addcontentsline{toc}{chapter}{#2}
}
% \topskip 50pt
%\titlespacing*{\mychapter}{0cm}{-50pt}{0pt}[0pt]

\begin{document}
\lstset{language=Prolog}          % Set your language (you can change the language for each code-block optionally)

\begin{titlepage}
	\newpage
	\thispagestyle{empty}
	\frenchspacing
	\hspace{-0.2cm}
	\includegraphics[height=3.4cm]{sedes}
	\hspace{0.2cm}
	\rule{0.5pt}{3.4cm}
	\hspace{0.2cm}
	\begin{minipage}[b]{8cm}
		\Large{Katholieke\newline Universiteit\newline Leuven}\smallskip\newline
		\large{}\smallskip\newline
		\textbf{Department of\newline Computer Science}\smallskip
	\end{minipage}
	\hspace{\stretch{1}}
	\vspace*{3.2cm}\vfill
	\begin{center}
		\begin{minipage}[t]{\textwidth}
			\begin{center}
				\LARGE{\rm{\textbf{\uppercase{Project}}}}\\
				\Large{\rm{Advanced Programming Languages for A.I. (H02A8a) }}\\
				\vspace{0.5cm}
			   
			    \large{\textsc{Deruyttere-Halilovic}}%
				
			\end{center}
		\end{minipage}
	\end{center}
	\vfill
	\hfill\makebox[8.5cm][l]{%
		\vbox to 7cm{\vfill\noindent
				{\rm \textbf{Thierry Deruyttere (r0660485)}}\\
				{\rm \textbf{Armin Halilovic (r0679689)}}\\[2mm]
				{\rm Academic year 2016-2017}
			
		}
	}
\end{titlepage}

\newpage
\tableofcontents
\newpage

\mychapter{0}{Introduction}
In this report we will discuss the different approaches we tried to eventually come to the solutions we have now for Sudoku and Hashiwokakero. The solutions we got are the result of a lot of work and a lot of back tracking on our previously done work. We often came in situations where we got stuck because of the limitations of the ECLiPSe and CHR systems but we also often had to back track on our work since we were often feeling that we were doing things in a non declarative way. We often tried to do things in a procedural way when we first started with Sudoku which means we lost quite some time here since we often had to rethink how we could write things in a more declarative way. For the Hashiwokakero part of the project things went a bit better but we lost quite some time here with the fact that ECLiPSe doesn't support constraints in conditionals. We will discuss this further in chapter \ref{sec:Hashiwokakero}. The fact that we often had to backtrack on our work was according to us due to the fact that we are still novices with prolog since this is the first time we used this programming language.
	\newline
	\newline
	In our solutions we decided to only use ECLiPSe and CHR. This was partially due to the fact that when we started this assignment we still hadn't seen Jess in class. Once we did have the class about Jess we found that since we were still novices at declarative programming languages, it would be a good exercise to continue using the more declarative systems to gain more experience with them since Jess can also be used to program in a more procedural way. Another reason for not using Jess was that the Jess syntax looked less appealing than the syntax CHR was offering us by all the parenthesizes used in its syntax.
	
%In this report we will discuss the solutions we created for Sudoku and Hashiwokakero and the different approaches that we tried. During the creation of our solution we often had to re-track our work since we often found that we were not trying to do things in a prolog-like way. This is was due to the fact that we are still novice's when using prolog. 
\mychapter{1}{Task 1: Sudoku}
\section{Other Viewpoint}
\label{sec:other_viewpoint}
For our other viewpoint for Sudoku we decided that each number has N positions (with N the size from one side of the sudoku board). Each of these (X,Y) positions must be different as well as each X must be different from the other positions as well as the Y. This representation has as a benefit that you know that each value from 1 to N must be in X, so we can already fill this in. The only thing left is to find the right Y.
\newline
\newline

\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{blockRow}
\caption{Illustration of the definition of a block row}
\end{figure}

The block constraints can be expressed with a bit of maths thank to this representation. We know each X of all the different positions of a number so we can check in which block row (see illustration) the position is. For example if you take a 9 x 9 board like in the illustration, you know that the rows 1,2,3 belong to block row 1, the rows 4,5,6 belongs to block row 2 and 7,8,9 belongs to block row 3. To express the block constraints we do the following:
\begin{enumerate}
	\item Take all the positions of a number
	\item Check which positions are in the same block row (there are exactly $\sqrt{N}$ positions of a number in the same block row).
	\item Express that each position in the same block row should be in a different block in that block row.
\end{enumerate}

\section{Criteria to judge if a viewpoint is good or not}
This is really difficult in our opinion since we had some problems at first to find a good other viewpoint. We think that a good criteria to judge if a viewpoint is good or not is how easy is it to express what you need with this viewpoint, obviously if you lose a lot of time with implementing an other viewpoint then it may be worth it to look for an other viewpoint. Another criteria is how easy is it to use this different viewpoint? In other words, is it a logical representation for the problem? Our final criteria for a good viewpoint is to think about the amount of constraints you need with this viewpoint. Is it really the lowest amount possible? 

\section{Channeling}
The channeling constraint for the two viewpoints we are using, the classical one and the one explained above, are in fact not that hard to express. If for the classical viewpoint you know which value there has to be in a certain cell, you also immediately know it's (X,Y) values. For the other viewpoint, if you know the (X,Y) values of a number then obviously you can enter the number at that position. 

\subsubsection{ECLiPSe channeling constraints}
\lstinputlisting[ language = Prolog-pretty, caption  = {Channel constraints in ECLiPSe} ]{eclipse_channel.pl}
%The first two lines of code are just to get the size of the Board and NumberPositions. Note that both of them are $N x N$, only NumberPositions has an extra dimension to store the (X,Y) pairs. 
	%After this we create the loop variables Number, Positions and Y, these will be used for the channeling constraint and they start from 1 to N.
	The crucial bit of code for the channeling constraints can be found inside the multifor. There you can find two different constraints that links the two viewpoints together. The first one is the channeling constraint for the classical viewpoint. It lays a constraint on the value of Board[Position,Y]. The second constraint is the channeling constraint for our viewpoint. There you can see that we index with \texttt{Number}, \texttt{Position} and 2. The reason we're only interested in the second value is because the first value is already filled in as stated in section \ref{sec:other_viewpoint}. Together these constraints expresses that if Y is know in our viewpoint then we can fill in the board with \texttt{Number} or if we know which number is at [Position,Y] in the classic viewpoint then we can fill in the Y of our viewpoint. (Or just refer to intro of 1.3 instead of repeat?) This is done with the B at the end of both of the constraints. This B is crucial in the channeling constraints as it expresses that if one of the constraints is correct, then the other should be correct as well!
	
\newpage
\subsubsection{CHR channeling constraints}
\lstinputlisting[ language = Prolog-pretty, caption  = {Channel constraints in CHR} ]{chr_channel.pl}
For the channeling constraints in CHR we decided to use an extra predicate \texttt{channel}. This is used just so that the system waits for the right moment to start setting up the channel constraints. Expressing the channeling constraints in CHR was a bit easier than doing it in ECLiPSe. Let's start with the first constraint. This expresses that if Value of board and board\_other\_viewpoint are the same and a are a number and Y2 and B2 are still variables then we can say that Y2 is Y and B2 is BlockIndex. We can say that Value has to be a number for board\_other\_viewpoint since this is trivial since we insert a number here at construction. The important part was that Y2 and B2 are still variables since this means that we still don't know their values. Why do we use 'is' instead of just removing the old board\_other\_viewpoint from the constraint store? If we would just remove the constraint then this would mean that other constraints would never be fired! That's why we use is! If Y2 and B2 gets their values this means that maybe other constraints can be solved too. If you remove this constraint from the store you lose this link.
\newline
\newline
For the second constraint we need to know that both Y and BlockIndex are numbers and V2 is still a var. Since we know both X, Y and BlockIndex then it is very easy to just fill in the Value of that position in board. We use 'is' for the same reason as mentioned before. If V2 finally get's a value then this means that there might be other propagations that can fire.
\newpage
\section{Experiments}
\subsection{ECLiPSe}
\subsubsection{input order as value heuristic, alldifferent from ic\_global}

\begin{table}[h!]
  \begin{tabular}{|c|c|c|c|c|c|c|}
    \hline
    \multirow{2}{*}{Puzzle} &
      \multicolumn{2}{L|}{Classical Viewpoint (input order)} &
      \multicolumn{2}{L|}{Our Viewpoint (input order)} &
      \multicolumn{2}{L|}{ Channeling (input order)} \\
    & ms & backtracks & ms & backtracks & ms & backtracks \\
    \hline
lambda & 0.01s & 3 & 74.669s & 78859 & 0.031s & 2\\
hard17 & 0.01s & 1 & 84.319s & 130134 & 0.041s & 0\\
eastermonster & 0.21s & 51 & 3.29s & 3278 & 0.139s & 24\\
tarek\_052 & 0.34s & 59 & 0.19s & 166 & 0.03s & 0\\
goldennugget & 0.671s & 104 & 12.79s & 11171 & 0.63s & 70\\
coloin & 0.22s & 88 & 6.469s & 4717 & 1.071s & 178\\
extra2 & 0.0s & 0 & 691.25s & 662099 & 0.05s & 4\\
extra3 & 0.011s & 3 & 70.23s & 78859 & 0.03s & 2\\
extra4 & 0.01s & 4 & 174.23s & 197306 & 0.03s & 3\\
inkara2012 & 0.03s & 3 & 4.23s & 5273 & 0.19s & 34\\
clue18 & 0.26s & 69 & 162.28s & 156554 & 0.17s & 20\\
clue17 & 0.01s & 0 & 180.65s & 191972 & 0.01s & 0\\
sudowiki\_nb28 & 1.03s & 413 & 39.82s & 40477 & 3.36s & 832\\
sudowiki\_nb49 & 0.19s & 48 & 9.86s & 10771 & 0.2s & 37\\
 \hline
  \end{tabular}
\end{table}

\subsubsection{input order as value heuristic, alldifferent from ic}

\begin{table}[h!]
  \begin{tabular}{|c|c|c|c|c|c|c|}
    \hline
    \multirow{2}{*}{Puzzle} &
      \multicolumn{2}{L|}{Classical Viewpoint (input order)} &
      \multicolumn{2}{L|}{Our Viewpoint (input order)} &
      \multicolumn{2}{L|}{ Channeling (input order)} \\
    & ms & backtracks & ms & backtracks & ms & backtracks \\
    \hline
lambda & 0.34s & 4712 & 36.93s & 99470 & 1.359s & 1155\\
hard17 & 0.07s & 873 & 53.289s & 153383 & 0.781s & 1187\\
eastermonster & 0.01s & 119 & 2.709s & 4361 & 0.131s & 85\\
tarek\_052 & 0.02s & 193 & 0.15s & 201 & 0.01s & 6\\
goldennugget & 0.06s & 520 & 8.81s & 16938 & 0.42s & 389\\
coloin & 0.19s & 2209 & 3.82s & 6998 & 0.76s & 676\\
extra2 & 0.18s & 4652 & 477.78s & 959808 & 6.57s & 13979\\
extra3 & 0.33s & 4712 & 34.6s & 99470 & 1.21s & 1155\\
extra4 & 0.95s & 15116 & 89.85s & 253873 & 1.19s & 1540\\
inkara2012 & 0.0s & 50 & 3.78s & 8033 & 0.26s & 196\\
clue18 & 0.14s & 1838 & 118.8s & 268974 & 3.19s & 3604\\
clue17 & 0.33s & 5520 & 98.43s & 227622 & 0.15s & 177\\
sudowiki\_nb28 & 0.21s & 2851 & 41.91s & 76081 & 2.33s & 2187\\
sudowiki\_nb49 & 0.11s & 1078 & 5.89s & 14424 & 0.18s & 232\\
 \hline
  \end{tabular}
\end{table}

\newpage
\subsubsection{first fail as value heuristic, alldifferent from ic\_global}

\begin{table}[h!]
  \begin{tabular}{|c|c|c|c|c|c|c|}
    \hline
    \multirow{2}{*}{Puzzle} &
      \multicolumn{2}{L|}{Classical Viewpoint (first fail)} &
      \multicolumn{2}{L|}{Our Viewpoint (first fail)} &
      \multicolumn{2}{L|}{ Channeling (first fail)} \\
    & ms & backtracks & ms & backtracks & ms & backtracks \\
    \hline
lambda & 0.02s & 3 & 24.07s & 32384 & 0.03s & 2\\
hard17 & 0.01s & 1 & 6.28s & 9183 & 0.02s & 0\\
eastermonster & 0.12s & 33 & 10.69s & 11599 & 0.17s & 25\\
tarek\_052 & 0.16s & 35 & 1.389s & 1502 & 0.071s & 6\\
goldennugget & 0.29s & 76 & 19.94s & 19870 & 0.39s & 59\\
coloin & 0.04s & 8 & 0.48s & 527 & 0.32s & 56\\
extra2 & 0.0s & 0 & 0.68s & 909 & 0.02s & 0\\
extra3 & 0.01s & 3 & 23.88s & 32384 & 0.03s & 2\\
extra4 & 0.01s & 3 & 585.84s & 858267 & 0.03s & 3\\
inkara2012 & 0.08s & 17 & 8.33s & 10942 & 0.08s & 15\\
clue18 & 0.04s & 8 & 175.63s & 221669 & 0.02s & 0\\
clue17 & 0.01s & 0 & 262.53s & 336082 & 0.019s & 0\\
sudowiki\_nb28 & 0.549s & 297 & 41.25s & 46872 & 1.25s & 344\\
sudowiki\_nb49 & 0.21s & 58 & 23.021s & 24536 & 0.219s & 38\\
 \hline
  \end{tabular}
\end{table}


\subsubsection{first fail as value heuristic, alldifferent from ic}
\begin{table}[h!]
  \begin{tabular}{|c|c|c|c|c|c|c|}
    \hline
    \multirow{2}{*}{Puzzle} &
      \multicolumn{2}{L|}{Classical Viewpoint (first fail)} &
      \multicolumn{2}{L|}{Our Viewpoint (first fail)} &
      \multicolumn{2}{L|}{ Channeling (first fail)} \\
    & ms & backracks & ms & backracks & ms & backracks \\
    \hline
lambda & 0.091s & 977 & 10.42s & 36846 & 1.2s & 1961\\
hard17 & 0.031s & 419 & 7.06s & 23036 & 0.139s & 386\\
eastermonster & 0.01s & 101 & 6.71s & 16122 & 0.11s & 122\\
tarek\_052 & 0.019s & 130 & 1.11s & 3178 & 0.05s & 45\\
goldennugget & 0.051s & 358 & 9.609s & 23741 & 0.261s & 310\\
coloin & 0.01s & 83 & 0.29s & 929 & 0.22s & 227\\
extra2 & 0.49s & 7690 & 0.3s & 1044 & 0.0s & 10\\
extra3 & 0.08s & 977 & 10.89s & 36846 & 1.34s & 1961\\
extra4 & 0.19s & 2097 & 289.22s & 986497 & 0.32s & 720\\
inkara2012 & 0.03s & 273 & 5.36s & 13509 & 0.09s & 108\\
clue18 & 0.05s & 439 & 88.58s & 256741 & 0.06s & 52\\
clue17 & 0.03s & 270 & 140.96s & 440342 & 0.01s & 15\\
sudowiki\_nb28 & 0.21s & 2221 & 20.19s & 60024 & 0.65s & 864\\
sudowiki\_nb49 & 0.07s & 655 & 11.9s & 32895 & 0.19s & 241\\
 \hline
  \end{tabular}
\end{table}
\newpage
\subsection{Impact of the different search strategies and alldifferent}
\subsubsection{Input order vs first fail}
When we compare the two tables for \texttt{input order} and \texttt{first fail} with the alldifferent from ic\_global we see that actually for most of the puzzles in all the three columns, the \texttt{first fail} heuristic does a better job than \texttt{input order}! We can see that there are sometimes really big differences between the two tables, for example 'extra2' for our viewpoint in the \texttt{input order} table has 662k backtracks but when you look over at the \texttt{first fail} table you see that it only has 909 backtracks! Though, it is not always \texttt{first fail} that is faster. If we look at 'extra4' for yet again our viewpoint we see that \texttt{input order} is faster this time! 197306 backtracks \texttt{input order} for vs 858267 backtracks \texttt{first fail}. This is quite odd behavior since 'extra4' is just puzzle 'extra3', where \texttt{first fail} outperforms \texttt{input order} by more than 50\%, with an extra hint.
\newline
\newline
When we look to the alldifferent from the ic library tables, we see exactly the same behavior as mentioned before. We see that most of the times \texttt{first fail} is faster than \texttt{input order} but yet again we observe the same odd behavior for 'extra4'. 

\subsubsection{ic\_global vs ic}
When we compare the alldifferent from ic\_global vs ic we see that the version from ic\_global is faster/does less backtracking! For our viewpoint the increase is not that big but when you look at the channeling column and the classical viewpoint, then you see that the increases in backtracks here are quite big! 

\subsection{Analysis of differences}
\subsubsection{input order vs first fail}

\subsubsection{alldifferent}
The difference with the alldifferent is due to the fact that the alldifferent from ic\_global has been programmed with stronger propagation behavior \footnote{\url{http://eclipseclp.org/doc/bips/lib/ic\_global/alldifferent-1.html}} than the alldifferent from the ic library as explained in class. The ic\_global implementation has a global view of the constraints and can thus make smarter decisions about it.
\newpage
\subsection{CHR}
\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{classicvsour}
\caption{Classic (red) vs our viewpoint (green). Figure shows only one block row.}
\label{fig:classic_vs_own}
\end{figure}

For the CHR implementation of the two viewpoints we had a lot of troubles getting something performant. When we run the two viewpoints on harder boards it takes easily a couple of minutes. Obviously this isn't good so we tried to improve the performance of both our implementations. The first classical viewpoint has some advantages over our other viewpoint since when you look at a block and there is only one spot left you know that whatever number is missing you should input it there. This can be seen on figure \ref{fig:classic_vs_own}. The red colored box is the only box left where 9 can be inputted from the classical point of view. By seeing this, we made our system quite faster! For the other viewpoint however, the only thing it can see are the squares bounded by the two green rectangles. The correct place is still available but it also sees unnecessary other spaces at this time.

\subsubsection{Heuristics classical viewpoint}
For the classical viewpoint we found that there was one obvious heuristic that we could use to try to improve the search.
To demonstrate this let's take for example the 'lambda' board from the puzzles provided on toledo. 

\begin{figure}[h]
    \centering
    \subfloat[Lambda board]{{\includegraphics[width=5cm]{lambda1}}}%
    \qquad
    \subfloat[Lambda board after heuristic]{{\includegraphics[width=5cm]{lambda2} }}%
    \caption{Lambda board pre vs post heuristic}%
    \label{fig:classic_heuristic}%
\end{figure}
When we look at \ref{fig:classic_heuristic}(a) we for example see that in the bottom left block, at the position (9,9), the only possible number that we can play there is a 6 since it cannot be put anywhere else in the block because of the two sixes of the blocks next to us. This information is critical to be able to solve sudoku's in a smart way. This is what we tried to do with our heuristic. Our heuristic will try to let (9,9) know that it is very likely that 6 should be put there. In fact it is 100\% 'likely' that 6 should be played there.
\newline
\newline
\newline
The way we do this is we check the domain of (9,9) and we compare it with the domains of all the other squares in the block. When doing this comparison we check for the numbers that is in our domain but not in the domain of the square we're comparing. If a number is not present in the domain of the comparing square, let's say 6 for example, then we know that the likelihood that this 6 is at our position increases. So what we do is we keep track of all the differences between the other squares and we count how many times we've seen a number. We then sort our domain according to this in a descending order. Obviously we want to try things that are very likely first and things that are less likely at a later moment. One important observation to this is that if the count of a number is equals to 9 you know that we are the only position that can play this number else we would never see this number appear 8 times from the differences. We get to 9 because we use our domain as a starting point, so this means that each number in our domain immediately gets a count of 1. We do this because it is not certain that when checking all the differences with the other squares, you will get all the values from your domain. So if we would only use the numbers from the differences we might for example never see a 2 while actually 2 was the only answer that could be played at that position in the end. 
\newline
\newline
This scenario happens when for example all the other squares had also a 2 in their domain so you will never see 2 in the difference set and since we reset the current domain to the likelihood domain this would mean that the 2 would be forever gone which might mean that the system keeps on backtracking to try everything until it sees that nothing is left anymore just to fail. This is obviously something that we want to prevent, this is why we start from our original domain. When we look at figure \ref{fig:classic_heuristic}(b), we can see the effect of our likelihood heuristic just before the start of the search. We see that already 5 different squares are filled in (the green and red ones). The green ones are some obvious plays but we were actually surprised when it played the red one. The other green ones are 'easy' because for example for the (9,9) example you see that this position is obviously the only place 6 can be played because of the other sixes. But for the red one we don't see a single other 8 on the board and yet it knew that it had to play an 8 there. We have to admit though that our system is a bit flawed since this heuristic cannot be used during the search since too many calculations are made. For example with everything we have filled in we could deduct that for the yellow square, 5 is the only possible play. But this is not feasible since it is way to slow to calculate this. This is why we ordered the domain according to likelihood. If we look at the domain of (2,1) sorted with likelihood, we see that the domain is [5, 3, 6, 8, 9]. So even though we're not fully sure that the 5 had to come there before we filled in the 4 in our block, our system captures the likelihood of a 5 at (2,1) still quite well.

\newpage
\subsubsection{Heuristics our viewpoint}
For our viewpoint it was a bit more difficult to find a heuristic and in fact we weren't really able to find a heuristic for it. The only thing that we found obvious to do is to make the domains smaller when we played a number.
\begin{figure}[h!]
\centering
\includegraphics[width=0.8\textwidth]{smartremoval}
\caption{Smart domain changes}
\label{fig:smart_domain}
\end{figure}
Let's say we want to play a 3 at the green square on figure \ref{fig:smart_domain}. Our initial domain would be from 1 to 9. If we play the 3 in the green square then we know that for all our other 3's that we cannot put them in the first column anymore. So the other domains for playing 3 will remove the first column from their domain. But this play actually contains more information which we try to exploit with our system. Since we played in the first column, we know that for the other 3's in this block row they cannot be played anywhere in block 1 anymore! So for their domain, instead of just removing the first column, we remove all the columns from the first block from their domain! This means that from 9 values we go to 6 immediately and if we play another 3 in this block row then the last 3 only has a search space of 3 left! By doing this small change we effectively speed up our system quite a bit. Before implementing this we recorded a time of 32s for one of our test boards, with these domain adjustments we went to 14s! So we effectively made our system at least twice as fast with this.

\mychapter{2}{Task 2: Hashiwokakero}
\label{sec:Hashiwokakero}

\section{ECLiPSe}

\subsection{Basic solver}
\subsubsection{Constraints}
The ECLiPSe Hashiwokakero solver is based on the stackoverflow post\footnote{\url{https://stackoverflow.com/questions/20337029/hashi-puzzle-representation\_-to-solve-all-solutions-with-prolog-restrictions}} given in the assignment. We have used the proposed data structure and constraints in the post, and have added constraints for the connectivity of the islands. The resulting constraints are:
\\
TODO: FIX WEIRD EXTRA BRACKETS IN CODE
\begin{itemize}
	\item For every position on the board it holds that the amount of bridges going in one direction (e.g. N) equals the amount of bridges going in the opposite direction (e.g. S) from the next position in the original direction (N in this example). If the position is on an edge of the board, the amount of bridges in the direction that would go outside of the board is zero.
	
	% This is wrong
	%For every island that is not on any of the borders on the board, a bridge that comes from a certain direction, needs to go out on the opposite direction. This means that any bridge coming from the North also leaves from the South or vice versa. Any bridge coming from the West leaves from the East or vice versa. If following one of the directions would mean that we would leave the board, put a 0 on that direction.
        \lstinputlisting[ language = Prolog-pretty ]{pass_through.pl}
        
    \item The sum of all bridges connected to an island must be equal to the number of the island. 
        \lstinputlisting[ language = Prolog-pretty ]{sum.pl}
        
    \item The amount of bridges going in one direction equals the amount of bridges going the opposite direction and bridges cannot cross each other. 
        \lstinputlisting[ language = Prolog-pretty ]{no_crossing.pl}
        
    \item The connectivity constraint is implemented by checking that all islands can be visited starting from a certain island. This is done after the search. fill\_set\_visit is called with a certain starting island. Then, the Visited list is filled with the islands that can be reached from the starting island. Afterwards, the length of Visited must equal the amount of islands on the board. If the length of Visited does not equal the amount of islands on the board, this means that not all islands can be visited from a certain island, which then means that the bridges do not connect the islands into a single connected set.
\begin{lstlisting}[ language = Prolog-pretty]
board_connected_set(Board) :-
    board_islands(Board, Islands),
    length(Islands, N),
    length(Visited, N),

    % make the island be member of current set
    nth1(1, Islands, [X, Y]),

    % set position to visited
    nth1(1, Visited, 1),

    % travel to the neighbors of the current position and fill the Islands/Visited set
    fill_set_visit(Board, X, Y, Islands, Visited),

    % if all free variables in Visited have been bound, then all islands form a connected set
    count_nonvars(Visited, N).
\end{lstlisting}
    
\end{itemize}
All the constraints are active, except for the connectivity constraints. The connectivity constraint does not directly make changes to domains of variables so it a passive constraint. The other constraints do make changes to domains. 
\subsection{Improvements}
When one thinks about improvements for solving Hashiwokakero there are a couple of obvious ones that pop up. For example, if there is a 4 in one of the four corners, the only way to get 4 bridges is by placing 2 bridges in the two possible directions. The same idea goes for a 6 at one of the edges of the board. Because one of it's directions is blocked, the only way to get 6 briges is by placing 2 bridges in all 3 of the possible directions. For an island with an 8, the only option is to place 2 bridges in every direction. These seem like good improvements, but actually they were already done implicitly by ECLiPSe's domain solving.
\newline

Since these were not really improvements to our solver, we had to look for other improvements. The following improvements are inspired by \url{http://www.conceptispuzzles.com/index.aspx?uri=puzzle/hashi/techniques}.

\begin{enumerate}
	\item The first improvement we made was stating that a 1 and another 1 cannot be connected directly to each other. If there was a bridge between them, we would immediately have an invalid solution, as all of the islands in the end result must form a single connected set. Another situation that corresponds with this idea is a 2 and another 2. These can never have 2 bridges between each other since then you would also create an isolated segment. By stating that there cannot be a bridge between islands with 1 and that there cannot be two bridges between islands with 2, we have added more knowledge before the search starts. \\
	Figure \ref{fig:improvement1} shows the result of this improvement. It shows two boards before the search phase. The board with the improvement contains two more briges before the search phase. This means that the during the search less backtracking will occur in the worst case.
	\begin{figure}[h]
    	\label{fig:improvement1}
        \centering
        \subfloat[board without improvement]{{\includegraphics[width=2cm]{one_to_one_imprv}}}%
        \qquad
        \subfloat[board with improvement]{{\includegraphics[width=2cm]{one_to_one_improv2} }}%
        \caption{boards without and with improvement}%
        \label{fig:classic_heuristic}%
    \end{figure}
    
	\item The second improvement builds further on the idea of avoiding isolated segments. 
	Assume there is an island with a 2 that has three neighbors, two of which are islands with 1. If you were to place a bridge from the 2 to both of the 1's, then you would end up with an isolated segment. In this case, we know that the third neighbor will have at least one bridge going to the 2. This is implemented by stating that the amount of bridges going from the 2 to the third neighbor cannot be zero. This adds more knowledge to start with before the search.
	
	\item The third improvement avoids isolated segments for islands with a 3 that have 3 neighbors, among which one neighbor has a 1 and another has a two. If you connect one bridge with the 1 and 2 bridges with the 2, you get an isolated segment. In this case, we know for sure that the third neighbor of the island with 3 has at least one bridge going to the 3. This is implemented by stating that the amount of bridges going from the 3 to the third neighbor cannot be zero. Again, this adds more knowledge to start with before the search.
\end{enumerate}

All three of the improvements have an impact on the connectivity constraint. Because the improvements avoid isolated segments before the search starts, the amount of backtracks (in the wost case) caused to satisfy the connectivity constraint will be reduced.

\subsection{Experiments}
    TODO

\newpage
\section{CHR}
\subsection{Data representation}
We used the same data representation as in the ECLiPSe solution. The data is stored in 'board/7' facts with variables X, Y, Am, N, E, S, W, where (X, Y) represents the position of the board, Am the amount of bridges that must be connected this position. N, E, S, and W represent the amount of bridges that go in a certain direction from position (X,Y). 

\subsection{Constraints representation}
\begin{itemize}
	\item The amount of bridges going in one direction equals the amount of bridges going in the opposite direction on the next position. 
	    \\TODO remove comment from pl file
		\lstinputlisting[ language = Prolog-pretty, caption = {INSERT CAPTION} ]{chr_bridges_bothways_hashi.pl}
	\item There are no crossing bridges. In other words, if the amount of bridges going in one direction is greater than zero, then the amount of bridges going in the perpendicular position must be zero.
	    \\TODO remove comment from pl file
		\lstinputlisting[ language = Prolog-pretty, caption = {INSERT CAPTION} ]{chr_bridges_crossing_hashi.pl}
	\item Bridges cannot go outside of the board. The amount of bridges going in a direction that would leave the board are set to zero here.
	    \\TODO remove comment from pl file
        \lstinputlisting[ language = Prolog-pretty, caption = {INSERT CAPTION} ]{chr_bridges_inside_hashi.pl}
	\item If on a certain position there is no island, then the amount of bridges that come in from a certain direction equals the amount of bridges that leave in the opposite direction.
	    \\TODO remove comment from pl file
        \lstinputlisting[ language = Prolog-pretty, caption = {INSERT CAPTION} ]{chr_directions_equal_hashi.pl}
	\item The amount of bridges connected to an island equals that island's amount. Three addition constraints are used here to represent \[ Amount = N + E + S + W \]
	    \\TODO remove comment from pl file
        \lstinputlisting[ language = Prolog-pretty, caption = {INSERT CAPTION} ]{chr_sum_hashi.pl}
\end{itemize}

\subsection{Propagation and search}
Constraint propagation is handled by the 'in/2', 'add/3' and 'eq/2' rules. The 'in/2' rule is used to set the domain of a variable. The domain of a variable is a list of integers represented by two integers A and B and is noted as 'A..B'. When the domain of a variable only contains one element (when A equals B), then the value of the variable is known. \\
The 'add/3' and 'eq/2' rules are used to represent the rules for addition and equality in the program. ADDITIONALLY (get it? heehehehehhehe), their job is to reduce the domains of variables (see lines 10, 11, and 16 in the listing below). This makes these constraints active constraints.  An example of the domain reduction goes as follows. Assume the following facts are known. 'X in 0..4', 'Y in 0..4', 'Z in 0..2', add(X, Y, Z). We know that \(X + Y\) must equal \(Z\), and that \(Z\) must lie between 0 and 2. Therefore, we can reduce the domains of \(X\) and \(Y\) from '0..4' to '0..2'. This kind of behaviour is implemented by line 16 in the code excerpt below.
\begin{lstlisting}[ language = Prolog-pretty, caption = {Constraint propagation} ]
% remove duplicate indomain constraints
X in A..B \ X in A..B <=> var(X) | true.
% when a variable's domain gets reduced to 1 number, set the value of the variable
X in A..A <=> var(X) | X = A.

% equality constraint
X eq Y <=> number(X), number(Y) | X == Y.
% equality domain constraint solving
X eq Y \ X in A..B, Y in C..D <=> A \== C | L is max(A, C), X in L..B, Y in L..D.
X eq Y \ X in A..B, Y in C..D <=> B \== D | U is min(B, D), X in A..U, Y in C..U.

% addition constraint
add(X, Y, Z) <=> number(X), number(Y), number(Z) | Z is X + Y.
% addition domain constraint solving
add(X, Y, Z) \ X in A..B, Y in C..D, Z in E..F <=>
    not( ( A >= E-D, B =< F-C, C >= E-B, D =< F-A, E >= A+C, F =< B+D ) ) |
        NewA is max(A, E-D), NewB is min(B, F-C), X in NewA..NewB,
        NewC is max(C, E-B), NewD is min(D, F-A), Y in NewC..NewD,
        NewE is max(E, A+C), NewF is min(F, B+D), Z in NewE..NewF.
\end{lstlisting}

The actual search for values of variables is handled by the 'search/0' and 'enum/1' rules. When 'enum/1' is fired with a variable that has a domain constraint ('X in A..B'), then it will cause X to take a value in its domain. Values are assigned to X by Prolog's 'between(A, B, X)' procedure. Each time X is assigned a value by this procedure, other rules may be fired, depending on what is in the constraint store at that time. Among those other rules could lie equality and adition constraints which can now further reduce domains of other variables because the domain of X has been removed. If this causes backtracking to happen back up to the 'between' procedure, the next value in the domain will be assigned to X. IS DIT DAN DIE 'what kind of propagation you support'?? 
\begin{lstlisting}[ language = Prolog-pretty, caption  = {Search} ]
% assign values to variables X. X must lie between A and B
enum(X)            <=> number(X) | true.
enum(X), X in A..B <=> between(A, B, X).

% search for constraint variables
search, X in _.._ ==> var(X) | enum(X).
\end{lstlisting}

\subsection{Connectivity constraint}
The constraint that in the end result, the bridges must connect all islands into a single connected group, is handled in two different ways.

\subsubsection{Version 1}
The first version implements the connectivity constraint by checking whether or not all islands are reachable from a certain island. 'reachable/2' is used to represent which positions on the board are reachable. The reachable set can be expanded whenever a new bridge between two islands ('connection/2') is detected. The actual connectivity constraint is represented by lines 10 and 11 in the excerpt below. If, after the search phase is over, there is an 'island/3' fact without an accompanying 'reachable/2' fact, then the islands are not connected into a single group. This then causes backtracking to happen which causes search to try other values for variables.

\begin{lstlisting}[ language = Prolog-pretty, caption  = {Connectivity constraint propagator 1} ]
% put first island in reachable set
island(X, Y, _) \ pick_first_island <=> reachable(X, Y).

% build up reachable set
reachable(X, Y) \ connected([X, Y], [A, B]) <=> reachable(A, B).
reachable(X, Y) \ connected([A, B], [X, Y]) <=> reachable(A, B).
reachable(X, Y) \ reachable(X, Y) <=> true.

% connectivity constraint: each island fact needs to have an accompanying reachable fact
connected \ island(X, Y, _), reachable(X, Y)  <=> true.
connected, island(_, _, _)                    <=> false.
\end{lstlisting}

\subsubsection{Version 2}
The second connectivity constraint propagator follows a similar idea, but implements it by using a disjoint-set-like data structure. After the puzzle board is loaded, each island forms its own 'connected set' (or segment). A counter 'connected\_sets\_counter/1' represents the amount of connected sets that are on the board. 'connected\_set/3' represents which island belongs to which connected set. After a bridge has been formed between two islands ('connected/2'), their connected sets are merged together (lines 1, 4, and 10 below) by changing the identifier of the smaller connected set into the identifier of the larger one. After the sets have been merged, the 'connected\_sets\_counter/1' is decremented. The actual connectivity constraint is represented by the last line in the code excerpt. If, after the search phase is over, there exists more than one connected set, then the solution is not valid, and backtracking is forced. \\
Compared to version 1, this connectivity constraint propagator is actually worse. This is because it is more costly to keep track of all of the connected sets during search than to just check whether or not all island are reachable from a certain island. However, subsection \ref{sec:improvement2} contains an improvement for this version which makes it perform better than the previous one.

\begin{lstlisting}[ language = Prolog-pretty, caption  = {Connectivity constraint propagator 2} ]
connected_set(A, B, Set1), connected_set(C, D, Set2), connected_set_counter(Set1, Count1)
    \ connected([A, B], [C, D]), connected_set_counter(Set2, Count2)  <=> Set1 \== Set2, Count2 =< Count1 |
        connected_sets_union(Set1, Set2).
connected_set(A, B, Set1), connected_set(C, D, Set2), connected_set_counter(Set1, Count1)
    \ connected([C, D], [A, B]), connected_set_counter(Set2, Count2)  <=> Set1 \== Set2, Count2 =< Count1 |
        connected_sets_union(Set1, Set2).
connected_set(A, B, Set), connected_set(C, D, Set) \ connected([A, B], [C, D]) <=> true.
connected_set(A, B, Set), connected_set(C, D, Set) \ connected([C, D], [A, B]) <=> true.

connected_sets_union(Set1, Set2) \ connected_set(X, Y, Set2), connected_set_counter(Set1, Count) <=> NCount is Count + 1 |
    connected_set(X, Y, Set1),
    connected_set_counter(Set1, NCount).
connected_sets_union(_, _), connected_sets_counter(Count) <=> NCount is Count - 1 | connected_sets_counter(NCount).

connected, connected_sets_counter(C) ==> C > 1 | fail.
\end{lstlisting}

\subsection{Improvements}
\subsubsection{Improvement 1}
Our first improvement in the CHR solution follows the same logic as the first improvement in the ECLiPSe solution. Islands with value 1 cannot be connected to one another and islands with value 2 cannot be connected by 2 bridges (because then they would form isolated segments). This is not detected automatically by the domain solving rules of 'eq/2' and 'add/3', so we have added 4 rules which reduce the domains of variables before the search phase starts. 

\begin{lstlisting}[ language = Prolog-pretty, caption  = {Connectivity constraint propagator 2} ]
% improvement A: island with 1 cannot be connected to other island with 1, so set variable to 0
make_domains, board(X1, Y1, 1, N, _, _, _), neighbors(X1, Y1, 'N', X2, Y2), island(X2, Y2, 1) \ N in _.._ <=> var(N) | N = 0.
make_domains, board(X1, Y1, 1, _, E, _, _), neighbors(X1, Y1, 'E', X2, Y2), island(X2, Y2, 1) \ E in _.._ <=> var(E) | E = 0.
% improvement B: 2 cannot be connected to 2 by 2 bridges, so make domain A..1
make_domains, board(X1, Y1, 2, N, _, _, _), neighbors(X1, Y1, 'N', X2, Y2), island(X2, Y2, 2) \ N in A..2 <=> var(N) | N in A..1.
make_domains, board(X1, Y1, 2, _, E, _, _), neighbors(X1, Y1, 'E', X2, Y2), island(X2, Y2, 2) \ E in A..2 <=> var(E) | E in A..1.
\end{lstlisting}

This improvement removes a lot of the guess work done by 'between/3', because the reduction of some of the domains can cause a domino effect to occur in which a lot of domains can subsequently be reduced. On some boards (LIST THEM HERE?) there isn't even a need for the search phase any more because the board can be solved by the domain solving of 'eq/2' and 'add/3'. \\
This improvement also has an impact on the connectivity constraint, as isolated sets like 1-1 and 2=2 cause the connectivity constraint to not be satisfied. This is particularly impactful for example on boards for which the solver would guess an isolated set like 1-1 right at the beginning of the search phase. In that case, backtracking would need to go over all choice points made after the variables included in the 1-1 set.

\subsubsection{Improvement 2}
\label{sec:improvement2}
The biggest flaw in the two connectivity constraint propagators was that checking the connectivity constraint only happens after a value has been assigned to all variables. The connected sets of the second connectivity constraint propagator allows us to detect isolated segments earlier during the search phase. First,  'no\_isolated\_segments/0' is added to the constraint store after a new value has been assigned to a variable. 'no\_isolated\_segments/0' is used to add 'connected\_set\_not\_isolated/1' into the constraint store. This then makes sure that each connected set currently on the board is not isolated. A connected set is not isolated when one of the islands in the set can still create a bridge (and this is possible when one of the directions in the 'board/7' is still a variable). If no such island is found in a set, then backtracking is forced (last line in the excerpt below). 

\begin{lstlisting}[ language = Prolog-pretty, caption  = {Connectivity constraint propagator 2} ]
search, X in _.._ ==> var(X) | enum(X), no_isolated_segments.

...

no_isolated_segments, connected_set_counter(Set, _) ==> connected_set_not_isolated(Set).
no_isolated_segments <=> true.

connected_sets_counter(1) \ connected_set_not_isolated(_) <=> true.
connected_set(X, Y, Set1), board(X, Y, _, N, _, _, _) \ connected_set_not_isolated(Set1) <=> var(N) | true.
connected_set(X, Y, Set1), board(X, Y, _, _, E, _, _) \ connected_set_not_isolated(Set1) <=> var(E) | true.
connected_set(X, Y, Set1), board(X, Y, _, _, _, S, _) \ connected_set_not_isolated(Set1) <=> var(S) | true.
connected_set(X, Y, Set1), board(X, Y, _, _, _, _, W) \ connected_set_not_isolated(Set1) <=> var(W) | true.
connected_set_not_isolated(_) <=> false.
\end{lstlisting}

This improvement has a large impact on the connectivity constraint, because now the connectivity constraint is checked during the search phase instead of after the search phase. If an isolated segment were to be formed early in the search phase, this improvement would detect it and cause backtracking to happen instantly, whereas without this improvement backtracking would need to go over all choice points made after the creation of the isolated set. The effect of this improvement is most visible on board 2; its solving time went from 1600s (check this / update table) with improvement 1 to 850s with improvement 1 and 2. This improvement did not have a great impact on most other boards. This is because most other boards had smaller and fewer (or zero in some cases) domains to chose from during the search phase because of the domain solving done by 'eq/2' and 'add/3' (CHECK THIS WITH UPDATED TABLE).

\subsection{Experiments}
\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|}
\hline
 board number & time without improvements &  time with improvements  \\ \hline
       1   & 0.054s & 0.047s \\
       3   & 0.03s & 0.031s \\
       4   & 0.059s & 0.06s \\
       5   & 0.057s & 0.054s \\
       6   & 0.127s & 0.117s \\
       8   & 0.004s & 0.006s \\
       9   & 0.007s & 0.006s \\
       10  & 27.567s & 1.389s \\
       11  & 0.046s & 0.046s \\
       12  & 0.055s & 0.051s \\
       13  & 0.066s & 0.058s \\
       14  & 0.092s & 0.075s \\
       15  & 1.614s & 1.533s \\
       16  & 1.186s & 1.143s \\
       17  & 2.254s & 0.229s \\
       2   & aborted after 6405s & 1001s \\
\hline
\end{tabular}
\caption{Improvements on CHR solver with connectivity propagator 1}
\end{table}

\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|}
\hline
       board number & time without improvements & time with improvements \\ \hline

       1   & 0.053s & 0.049s\\
       3   & 0.029s & 0.026s\\
       4   & 0.056s & 0.061s\\
       5   & 0.053s & 0.056s\\
       6   & 0.128s & 0.118s\\
       8   & 0.007s & 0.004s\\
       9   & 0.007s & 0.008s\\
       10  & 28.369s & 1.364s\\
       11  & 0.053s & 0.047s\\
       12  & 0.048s & 0.052s\\
       13  & 0.06s & 0.057s\\
       14  & 0.087s & 0.076s\\
       15  & 1.701s & 1.573s\\
       16  & 1.219s & 1.156s\\
       17  & 2.292s & 0.23s\\
       2   & unknown & 847s \\
\hline
\end{tabular}
\caption{Improvements on CHR solver with connectivity propagator 2}

\end{table}

\mychapter{3}{Conclusion}

\section{Weak points}
CHR Sudoku speed (because we didn't know CHR that well of zo iets)
Connectivity constraint in ECLiPSe (because we couldn't figure out how to implement the connectivity constraint making use of connected sets as in CHR version 2)

\section{Strong points}
Thierry big strong man
BEAUTIFUL AMAZING GORGEOUS 100\% GENIUS CHR HASHI CODE (maar nog altijd heel traag op board 2 lol)

\section{Lessons learned}
Never use this system ever again. CHR pro dingetjes enzuuuu

\mychapter{4}{Appendix}
We started working on this project before the Easter holiday. In the beginning we often lost quite some time, since we didn't really know how the systems worked. During the second week of the Easter holiday, we continued to work on the project each evening and we finished the Sudoku task and the ECLiPSe part of hashiwokakero before the end of the holiday. We then had to halt our work for a while since we had a deadline for a ridiculously large project for another course. As the semester was coming to an end other deadlines and an exam were coming up so we had to manage those first. Thus it was only at the start of the study period that we could continue working. From the start of the study period we tried to spend around 6 hours of work each day for this project. The work was not really divided since we were doing pair programming most of the time. Sometimes someone made individual changes when they had time but most of our work was done online using Hangouts and its screen sharing functionality. We could argue that by doing pair programming we lost quite some time, which is true, but by doing this we worked very closely together and we learned quite a lot.  

\end{document}
