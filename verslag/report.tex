\documentclass{report}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{titlesec}
\usepackage[tmargin=2.0cm, lmargin=4.5cm, rmargin=5cm]{geometry}
\usepackage{listings}             % Include the listings-package
\usepackage{textcomp}
\usepackage{listings}
%\usepackage{minted}      % (requires -shell-escape)
\usepackage{xcolor}
\usepackage{filecontents}
\usepackage{array}
\usepackage{multirow}
\usepackage{hyperref}
\usepackage{subfig}

\newcolumntype{L}{>{\centering\arraybackslash}m{3cm}}

% --- ugly internals for language definition ---
%
\makeatletter

% initialisation of user macros
\newcommand\PrologPredicateStyle{}
\newcommand\PrologVarStyle{}
\newcommand\PrologAnonymVarStyle{}
\newcommand\PrologAtomStyle{}
\newcommand\PrologOtherStyle{}
\newcommand\PrologCommentStyle{}

% useful switches (to keep track of context)
\newif\ifpredicate@prolog@
\newif\ifwithinparens@prolog@

% save definition of underscore for test
\lst@SaveOutputDef{`_}\underscore@prolog

% local variables
\newcount\currentchar@prolog

\newcommand\@testChar@prolog%
{%
  % if we're in processing mode...
  \ifnum\lst@mode=\lst@Pmode%
    \detectTypeAndHighlight@prolog%
  \else
    % ... or within parentheses
    \ifwithinparens@prolog@%
      \detectTypeAndHighlight@prolog%
    \fi
  \fi
  % Some housekeeping...
  \global\predicate@prolog@false%
}

% helper macros
\newcommand\detectTypeAndHighlight@prolog
{%
  % First, assume that we have an atom.
  \def\lst@thestyle{\PrologAtomStyle}%
  % Test whether we have a predicate and modify the style accordingly.
  \ifpredicate@prolog@%
    \def\lst@thestyle{\PrologPredicateStyle}%
  \else
    % Test whether we have a predicate and modify the style accordingly.
    \expandafter\splitfirstchar@prolog\expandafter{\the\lst@token}%
    % Check whether the identifier starts by an underscore.
    \expandafter\ifx\@testChar@prolog\underscore@prolog%
      % Check whether the identifier is '_' (anonymous variable)
      \ifnum\lst@length=1%
        \let\lst@thestyle\PrologAnonymVarStyle%
      \else
        \let\lst@thestyle\PrologVarStyle%
      \fi
    \else
      % Check whether the identifier starts by a capital letter.
      \currentchar@prolog=65
      \loop
        \expandafter\ifnum\expandafter`\@testChar@prolog=\currentchar@prolog%
          \let\lst@thestyle\PrologVarStyle%
          \let\iterate\relax
        \fi
        \advance \currentchar@prolog by 1
        \unless\ifnum\currentchar@prolog>90
      \repeat
    \fi
  \fi
}
\newcommand\splitfirstchar@prolog{}
\def\splitfirstchar@prolog#1{\@splitfirstchar@prolog#1\relax}
\newcommand\@splitfirstchar@prolog{}
\def\@splitfirstchar@prolog#1#2\relax{\def\@testChar@prolog{#1}}

% helper macro for () delimiters
\def\beginlstdelim#1#2%
{%
  \def\endlstdelim{\PrologOtherStyle #2\egroup}%
  {\PrologOtherStyle #1}%
  \global\predicate@prolog@false%
  \withinparens@prolog@true%
  \bgroup\aftergroup\endlstdelim%
}

% language name
\newcommand\lang@prolog{Prolog-pretty}
% ``normalised'' language name
\expandafter\lst@NormedDef\expandafter\normlang@prolog%
  \expandafter{\lang@prolog}

% language definition
\expandafter\expandafter\expandafter\lstdefinelanguage\expandafter%
{\lang@prolog}
{%
  language            = Prolog,
  keywords            = {},      % reset all preset keywords
  showstringspaces    = false,
  linewidth			  = 16cm,
  numbers			   =left, 
  alsoletter          = (,
  alsoother           = @\$,
  moredelim           = **[is][\beginlstdelim{(}{)}]{(}{)},
  MoreSelectCharTable =
    \lst@DefSaveDef{`(}\opparen@prolog{\global\predicate@prolog@true\opparen@prolog},
}

% Hooking into listings to test each ``identifier''
\newcommand\@ddedToOutput@prolog\relax
\lst@AddToHook{Output}{\@ddedToOutput@prolog}

\lst@AddToHook{PreInit}
{%
  \ifx\lst@language\normlang@prolog%
    \let\@ddedToOutput@prolog\@testChar@prolog%
  \fi
}

\lst@AddToHook{DeInit}{\renewcommand\@ddedToOutput@prolog{}}

\makeatother
%
% --- end of ugly internals ---


% --- definition of a custom style similar to that of Pygments ---
% custom colors
\definecolor{PrologPredicate}{RGB}{000,031,255}
\definecolor{PrologVar}      {RGB}{024,021,125}
\definecolor{PrologAnonymVar}{RGB}{000,127,000}
\definecolor{PrologAtom}     {RGB}{186,032,032}
\definecolor{PrologComment}  {RGB}{063,128,127}
\definecolor{PrologOther}    {RGB}{000,000,000}

% redefinition of user macros for Prolog style
\renewcommand\PrologPredicateStyle{\color{PrologPredicate}}
\renewcommand\PrologVarStyle{\color{PrologVar}}
\renewcommand\PrologAnonymVarStyle{\color{PrologAnonymVar}}
\renewcommand\PrologAtomStyle{\color{PrologAtom}}
\renewcommand\PrologCommentStyle{\itshape\color{PrologComment}}
\renewcommand\PrologOtherStyle{\color{PrologOther}}

% custom style definition 
\lstdefinestyle{Prolog-pygsty}
{
  language     = Prolog-pretty,
  upquote      = true,
  stringstyle  = \PrologAtomStyle,
  commentstyle = \PrologCommentStyle,
  literate     =
    {:-}{{\PrologOtherStyle :-}}2
    {,}{{\PrologOtherStyle ,}}1
    {.}{{\PrologOtherStyle .}}1
}

% global settings
\lstset
{
  captionpos = below,
  frame      = single,
  columns    = fullflexible,
  basicstyle = \ttfamily,
}

%\titlespacing*{\chapter}{0pt}{-19pt}{18pt}

%\title{APLAI}
%\author{thierryderuyttere }
%\date{May 2017}
\newcommand{\mychapter}[2]{
    \setcounter{chapter}{#1}
    \setcounter{section}{0}
    \chapter*{#2}
    \addcontentsline{toc}{chapter}{#2}
}
% \topskip 50pt
%\titlespacing*{\mychapter}{0cm}{-50pt}{0pt}[0pt]

\begin{document}
\lstset{language=Prolog}          % Set your language (you can change the language for each code-block optionally)

\begin{titlepage}
	\newpage
	\thispagestyle{empty}
	\frenchspacing
	\hspace{-0.2cm}
	\includegraphics[height=3.4cm]{sedes}
	\hspace{0.2cm}
	\rule{0.5pt}{3.4cm}
	\hspace{0.2cm}
	\begin{minipage}[b]{8cm}
		\Large{Katholieke\newline Universiteit\newline Leuven}\smallskip\newline
		\large{}\smallskip\newline
		\textbf{Department of\newline Computer Science}\smallskip
	\end{minipage}
	\hspace{\stretch{1}}
	\vspace*{3.2cm}\vfill
	\begin{center}
		\begin{minipage}[t]{\textwidth}
			\begin{center}
				\LARGE{\rm{\textbf{\uppercase{Project}}}}\\
				\Large{\rm{Advanced Programming Languages for A.I. (H02A8a) }}\\
				\vspace{0.5cm}
			   
			    \large{\textsc{Halilovic-Deruyttere}}%
				
			\end{center}
		\end{minipage}
	\end{center}
	\vfill
	\hfill\makebox[8.5cm][l]{%
		\vbox to 7cm{\vfill\noindent
				{\rm \textbf{Armin Halilovic (r0679689)}}\\
				{\rm \textbf{Thierry Deruyttere (r0660485)}}\\[2mm]
				{\rm Academic year 2016-2017}
			
		}
	}
\end{titlepage}

\newpage
\tableofcontents
\newpage

\mychapter{0}{Introduction}
In this report we will discuss the different approaches we tried to eventually come to the solutions we have now for Sudoku and Hashiwokakero. The solutions we got are the result of a lot of work and a lot of back tracking on our previously done work. We often came in situations where we got stuck because of the limitations of the ECLiPSe and CHR systems but we also often had to back track on our work since we were often feeling that we were doing things in a non declarative way. We often tried to do things in a procedural way when we first started with Sudoku which means we lost quite some time here since we often had to rethink how we could write things in a more declarative way. For the Hashiwokakero part of the project things went a bit better but we lost quite some time here with the fact that ECLiPSe doesn't support constraints in conditionals. We will discuss this further in chapter \ref{sec:Hashiwokakero}. The fact that we often had to backtrack on our work was according to us due to the fact that we are still novices with prolog since this is the first time we used this programming language.
	\newline
	\newline
	In our solutions we decided to only use ECLiPSe and CHR. This was partially due to the fact that when we started this assignment we still hadn't seen Jess in class. Once we did have the class about Jess we found that since we were still novices at declarative programming languages, it would be a good exercise to continue using the more declarative systems to gain more experience with them since Jess can also be used to program in a more procedural way. Another reason for not using Jess was that the Jess syntax looked less appealing than the syntax CHR was offering us by all the parenthesizes used in its syntax.
	
%In this report we will discuss the solutions we created for Sudoku and Hashiwokakero and the different approaches that we tried. During the creation of our solution we often had to re-track our work since we often found that we were not trying to do things in a prolog-like way. This is was due to the fact that we are still novice's when using prolog. 
\mychapter{1}{Part 1: Sudoku}
\section{Other Viewpoint}
\label{sec:other_viewpoint}
For our other viewpoint for Sudoku we decided that each number has N positions (with N the size from one side of the sudoku board). Each of these (X,Y) positions must be different as well as each X must be different from the other positions as well as the Y. This representation has as a benefit that you know that each value from 1 to N must be in X, so we can already fill this in. The only thing left is to find the right Y.
\newline
\newline

\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{blockRow}
\caption{Illustration of the definition of a block row}
\end{figure}

The block constraints can be expressed with a bit of maths thank to this representation. We know each X of all the different positions of a number so we can check in which block row (see illustration) the position is. For example if you take a 9 x 9 board like in the illustration, you know that the rows 1,2,3 belong to block row 1, the rows 4,5,6 belongs to block row 2 and 7,8,9 belongs to block row 3. To express the block constraints we do the following:
\begin{enumerate}
	\item Take all the positions of a number
	\item Check which positions are in the same block row (there are exactly $\sqrt{N}$ positions of a number in the same block row).
	\item Express that each position in the same block row should be in a different block in that block row.
\end{enumerate}

\section{Criteria to judge if a viewpoint is good or not}
This is really difficult in our opinion since we had some problems at first to find a good other viewpoint. We think that a good criteria to judge if a viewpoint is good or not is how easy is it to express what you need with this viewpoint, obviously if you lose a lot of time with implementing an other viewpoint then it may be worth it to look for an other viewpoint. Another criteria is how easy is it to use this different viewpoint? In other words, is it a logical representation for the problem? Our final criteria for a good viewpoint is to think about the amount of constraints you need with this viewpoint. Is it really the lowest amount possible? 

\section{Channeling}
The channeling constraint for the two viewpoints we are using, the classical one and the one explained above, are in fact not that hard to express. If for the classical viewpoint you know which value there has to be in a certain cell, you also immediately know it's (X,Y) values. For the other viewpoint, if you know the (X,Y) values of a number then obviously you can enter the number at that position. 

\subsubsection{ECLiPSe channeling constraints}
\lstinputlisting[
  language = Prolog-pretty,
  caption  = {Channel constraints in ECLiPSe},
]{eclipse_channel.pl}
%The first two lines of code are just to get the size of the Board and NumberPositions. Note that both of them are $N x N$, only NumberPositions has an extra dimension to store the (X,Y) pairs. 
	%After this we create the loop variables Number, Positions and Y, these will be used for the channeling constraint and they start from 1 to N.
	The crucial bit of code for the channeling constraints can be found inside the multifor. There you can find two different constraints that links the two viewpoints together. The first one is the channeling constraint for the classical viewpoint. It lays a constraint on the value of Board[Position,Y]. The second constraint is the channeling constraint for our viewpoint. There you can see that we index with \texttt{Number}, \texttt{Position} and 2. The reason we're only interested in the second value is because the first value is already filled in as stated in section \ref{sec:other_viewpoint}. Together these constraints expresses that if Y is know in our viewpoint then we can fill in the board with \texttt{Number} or if we know which number is at [Position,Y] in the classic viewpoint then we can fill in the Y of our viewpoint. (Or just refer to intro of 1.3 instead of repeat?) This is done with the B at the end of both of the constraints. This B is crucial in the channeling constraints as it expresses that if one of the constraints is correct, then the other should be correct as well!
	
\newpage
\subsubsection{CHR channeling constraints}
\lstinputlisting[
  language = Prolog-pretty,
  caption  = {Channel constraints in CHR},
]{chr_channel.pl}
For the channeling constraints in CHR we decided to use an extra predicate \texttt{channel}. This is used just so that the system waits for the right moment to start setting up the channel constraints. Expressing the channeling constraints in CHR was a bit easier than doing it in ECLiPSe. Let's start with the first constraint. This expresses that if Value of board and board\_other\_viewpoint are the same and a are a number and Y2 and B2 are still variables then we can say that Y2 is Y and B2 is BlockIndex. We can say that Value has to be a number for board\_other\_viewpoint since this is trivial since we insert a number here at construction. The important part was that Y2 and B2 are still variables since this means that we still don't know their values. Why do we use 'is' instead of just removing the old board\_other\_viewpoint from the constraint store? If we would just remove the constraint then this would mean that other constraints would never be fired! That's why we use is! If Y2 and B2 gets their values this means that maybe other constraints can be solved too. If you remove this constraint from the store you lose this link.
\newline
\newline
For the second constraint we need to know that both Y and BlockIndex are numbers and V2 is still a var. Since we know both X, Y and BlockIndex then it is very easy to just fill in the Value of that position in board. We use 'is' for the same reason as mentioned before. If V2 finally get's a value then this means that there might be other propagations that can fire.
\newpage
\section{Experiments}
\subsection{ECLiPSe}
\subsubsection{input order as value heuristic, alldifferent from ic\_global}

\begin{table}[h!]
  \begin{tabular}{|c|c|c|c|c|c|c|}
    \hline
    \multirow{2}{*}{Puzzle} &
      \multicolumn{2}{L|}{Classical Viewpoint (input order)} &
      \multicolumn{2}{L|}{Our Viewpoint (input order)} &
      \multicolumn{2}{L|}{ Channeling (input order)} \\
    & ms & backtracks & ms & backtracks & ms & backtracks \\
    \hline
lambda & 0.01s & 3 & 74.669s & 78859 & 0.031s & 2\\
hard17 & 0.01s & 1 & 84.319s & 130134 & 0.041s & 0\\
eastermonster & 0.21s & 51 & 3.29s & 3278 & 0.139s & 24\\
tarek\_052 & 0.34s & 59 & 0.19s & 166 & 0.03s & 0\\
goldennugget & 0.671s & 104 & 12.79s & 11171 & 0.63s & 70\\
coloin & 0.22s & 88 & 6.469s & 4717 & 1.071s & 178\\
extra2 & 0.0s & 0 & 691.25s & 662099 & 0.05s & 4\\
extra3 & 0.011s & 3 & 70.23s & 78859 & 0.03s & 2\\
extra4 & 0.01s & 4 & 174.23s & 197306 & 0.03s & 3\\
inkara2012 & 0.03s & 3 & 4.23s & 5273 & 0.19s & 34\\
clue18 & 0.26s & 69 & 162.28s & 156554 & 0.17s & 20\\
clue17 & 0.01s & 0 & 180.65s & 191972 & 0.01s & 0\\
sudowiki\_nb28 & 1.03s & 413 & 39.82s & 40477 & 3.36s & 832\\
sudowiki\_nb49 & 0.19s & 48 & 9.86s & 10771 & 0.2s & 37\\
 \hline
  \end{tabular}
\end{table}

\subsubsection{input order as value heuristic, alldifferent from ic}

\begin{table}[h!]
  \begin{tabular}{|c|c|c|c|c|c|c|}
    \hline
    \multirow{2}{*}{Puzzle} &
      \multicolumn{2}{L|}{Classical Viewpoint (input order)} &
      \multicolumn{2}{L|}{Our Viewpoint (input order)} &
      \multicolumn{2}{L|}{ Channeling (input order)} \\
    & ms & backtracks & ms & backtracks & ms & backtracks \\
    \hline
lambda & 0.34s & 4712 & 36.93s & 99470 & 1.359s & 1155\\
hard17 & 0.07s & 873 & 53.289s & 153383 & 0.781s & 1187\\
eastermonster & 0.01s & 119 & 2.709s & 4361 & 0.131s & 85\\
tarek\_052 & 0.02s & 193 & 0.15s & 201 & 0.01s & 6\\
goldennugget & 0.06s & 520 & 8.81s & 16938 & 0.42s & 389\\
coloin & 0.19s & 2209 & 3.82s & 6998 & 0.76s & 676\\
extra2 & 0.18s & 4652 & 477.78s & 959808 & 6.57s & 13979\\
extra3 & 0.33s & 4712 & 34.6s & 99470 & 1.21s & 1155\\
extra4 & 0.95s & 15116 & 89.85s & 253873 & 1.19s & 1540\\
inkara2012 & 0.0s & 50 & 3.78s & 8033 & 0.26s & 196\\
clue18 & 0.14s & 1838 & 118.8s & 268974 & 3.19s & 3604\\
clue17 & 0.33s & 5520 & 98.43s & 227622 & 0.15s & 177\\
sudowiki\_nb28 & 0.21s & 2851 & 41.91s & 76081 & 2.33s & 2187\\
sudowiki\_nb49 & 0.11s & 1078 & 5.89s & 14424 & 0.18s & 232\\
 \hline
  \end{tabular}
\end{table}

\newpage
\subsubsection{first fail as value heuristic, alldifferent from ic\_global}

\begin{table}[h!]
  \begin{tabular}{|c|c|c|c|c|c|c|}
    \hline
    \multirow{2}{*}{Puzzle} &
      \multicolumn{2}{L|}{Classical Viewpoint (first fail)} &
      \multicolumn{2}{L|}{Our Viewpoint (first fail)} &
      \multicolumn{2}{L|}{ Channeling (first fail)} \\
    & ms & backtracks & ms & backtracks & ms & backtracks \\
    \hline
lambda & 0.02s & 3 & 24.07s & 32384 & 0.03s & 2\\
hard17 & 0.01s & 1 & 6.28s & 9183 & 0.02s & 0\\
eastermonster & 0.12s & 33 & 10.69s & 11599 & 0.17s & 25\\
tarek\_052 & 0.16s & 35 & 1.389s & 1502 & 0.071s & 6\\
goldennugget & 0.29s & 76 & 19.94s & 19870 & 0.39s & 59\\
coloin & 0.04s & 8 & 0.48s & 527 & 0.32s & 56\\
extra2 & 0.0s & 0 & 0.68s & 909 & 0.02s & 0\\
extra3 & 0.01s & 3 & 23.88s & 32384 & 0.03s & 2\\
extra4 & 0.01s & 3 & 585.84s & 858267 & 0.03s & 3\\
inkara2012 & 0.08s & 17 & 8.33s & 10942 & 0.08s & 15\\
clue18 & 0.04s & 8 & 175.63s & 221669 & 0.02s & 0\\
clue17 & 0.01s & 0 & 262.53s & 336082 & 0.019s & 0\\
sudowiki\_nb28 & 0.549s & 297 & 41.25s & 46872 & 1.25s & 344\\
sudowiki\_nb49 & 0.21s & 58 & 23.021s & 24536 & 0.219s & 38\\
 \hline
  \end{tabular}
\end{table}


\subsubsection{first fail as value heuristic, alldifferent from ic}
\begin{table}[h!]
  \begin{tabular}{|c|c|c|c|c|c|c|}
    \hline
    \multirow{2}{*}{Puzzle} &
      \multicolumn{2}{L|}{Classical Viewpoint (first fail)} &
      \multicolumn{2}{L|}{Our Viewpoint (first fail)} &
      \multicolumn{2}{L|}{ Channeling (first fail)} \\
    & ms & backracks & ms & backracks & ms & backracks \\
    \hline
lambda & 0.091s & 977 & 10.42s & 36846 & 1.2s & 1961\\
hard17 & 0.031s & 419 & 7.06s & 23036 & 0.139s & 386\\
eastermonster & 0.01s & 101 & 6.71s & 16122 & 0.11s & 122\\
tarek\_052 & 0.019s & 130 & 1.11s & 3178 & 0.05s & 45\\
goldennugget & 0.051s & 358 & 9.609s & 23741 & 0.261s & 310\\
coloin & 0.01s & 83 & 0.29s & 929 & 0.22s & 227\\
extra2 & 0.49s & 7690 & 0.3s & 1044 & 0.0s & 10\\
extra3 & 0.08s & 977 & 10.89s & 36846 & 1.34s & 1961\\
extra4 & 0.19s & 2097 & 289.22s & 986497 & 0.32s & 720\\
inkara2012 & 0.03s & 273 & 5.36s & 13509 & 0.09s & 108\\
clue18 & 0.05s & 439 & 88.58s & 256741 & 0.06s & 52\\
clue17 & 0.03s & 270 & 140.96s & 440342 & 0.01s & 15\\
sudowiki\_nb28 & 0.21s & 2221 & 20.19s & 60024 & 0.65s & 864\\
sudowiki\_nb49 & 0.07s & 655 & 11.9s & 32895 & 0.19s & 241\\
 \hline
  \end{tabular}
\end{table}
\newpage
\subsection{Impact of the different search strategies and alldifferent}
\subsubsection{Input order vs first fail}
When we compare the two tables for \texttt{input order} and \texttt{first fail} with the alldifferent from ic\_global we see that actually for most of the puzzles in all the three columns, the \texttt{first fail} heuristic does a better job than \texttt{input order}! We can see that there are sometimes really big differences between the two tables, for example 'extra2' for our viewpoint in the \texttt{input order} table has 662k backtracks but when you look over at the \texttt{first fail} table you see that it only has 909 backtracks! Though, it is not always \texttt{first fail} that is faster. If we look at 'extra4' for yet again our viewpoint we see that \texttt{input order} is faster this time! 197306 backtracks \texttt{input order} for vs 858267 backtracks \texttt{first fail}. This is quite odd behavior since 'extra4' is just puzzle 'extra3', where \texttt{first fail} outperforms \texttt{input order} by more than 50\%, with an extra hint.
\newline
\newline
When we look to the alldifferent from the ic library tables, we see exactly the same behavior as mentioned before. We see that most of the times \texttt{first fail} is faster than \texttt{input order} but yet again we observe the same odd behavior for 'extra4'. 

\subsubsection{ic\_global vs ic}
When we compare the alldifferent from ic\_global vs ic we see that the version from ic\_global is faster/does less backtracking! For our viewpoint the increase is not that big but when you look at the channeling column and the classical viewpoint, then you see that the increases in backtracks here are quite big! 

\subsection{Analysis of differences}
\subsubsection{input order vs first fail}

\subsubsection{alldifferent}
The difference with the alldifferent is due to the fact that the alldifferent from ic\_global has been programmed with stronger propagation behavior \footnote{\url{http://eclipseclp.org/doc/bips/lib/ic\_global/alldifferent-1.html}} than the alldifferent from the ic library as explained in class. The ic\_global implementation has a global view of the constraints and can thus make smarter decisions about it.
\newpage
\subsection{CHR}
\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{classicvsour}
\caption{Classic (red) vs our viewpoint (green). Figure shows only one block row.}
\label{fig:classic_vs_own}
\end{figure}

For the CHR implementation of the two viewpoints we had a lot of troubles getting something performant. When we run the two viewpoints on harder boards it takes easily a couple of minutes. Obviously this isn't good so we tried to improve the performance of both our implementations. The first classical viewpoint has some advantages over our other viewpoint since when you look at a block and there is only one spot left you know that whatever number is missing you should input it there. This can be seen on figure \ref{fig:classic_vs_own}. The red colored box is the only box left where 9 can be inputted from the classical point of view. By seeing this, we made our system quite faster! For the other viewpoint however, the only thing it can see are the squares bounded by the two green rectangles. The correct place is still available but it also sees unnecessary other spaces at this time.

\subsubsection{Heuristics classical viewpoint}
For the classical viewpoint we found that there was one obvious heuristic that we could use to try to improve the search.
To demonstrate this let's take for example the 'lambda' board from the puzzles provided on toledo. 

\begin{figure}[h]
    \centering
    \subfloat[Lambda board]{{\includegraphics[width=5cm]{lambda1}}}%
    \qquad
    \subfloat[Lambda board after heuristic]{{\includegraphics[width=5cm]{lambda2} }}%
    \caption{Lambda board pre vs post heuristic}%
    \label{fig:classic_heuristic}%
\end{figure}
When we look at \ref{fig:classic_heuristic}(a) we for example see that in the bottom left block, at the position (9,9), the only possible number that we can play there is a 6 since it cannot be put anywhere else in the block because of the two sixes of the blocks next to us. This information is critical to be able to solve sudoku's in a smart way. This is what we tried to do with our heuristic. Our heuristic will try to let (9,9) know that it is very likely that 6 should be put there. 
\newline
\newline
\newline
The way we do this is we check the domain of (9,9) and we compare it with the domains of all the other squares in the block. When doing this comparison we check for the numbers that is in our domain but not in the domain of the square we're comparing. If a number is not present in the domain of the comparing square, let's say 6 for example, then we know that the likelihood that this 6 is at our position increases. So what we do is we keep track of all the differences between the other squares and we count how many times we've seen a number. We then sort our domain according to this in a descending order. Obviously we want to try things that are very likely first and things that are less likely at a later moment. One important observation to this is that if the count of a number is equals to 9 you know that we are the only position that can play this number else we would never see this number appear 8 times from the differences. We get to 9 because we use our domain as a starting point, so this means that each number in our domain immediately gets a count of 1. We do this because it is not certain that when checking all the differences with the other squares, you will get all the values from your domain. So if we would only use the numbers from the differences we might for example never see a 2 while actually 2 was the only answer that could be played at that position in the end. 
\newline
\newline
This scenario happens when for example all the other squares had also a 2 in their domain so you will never see 2 in the difference set and since we reset the current domain to the likelihood domain this would mean that the 2 would be forever gone which might mean that the system keeps on backtracking to try everything until it sees that nothing is left anymore just to fail. This is obviously something that we want to prevent, this is why we start from our original domain. When we look at figure \ref{fig:classic_heuristic}(b), we can see the effect of our likelihood heuristic just before the start of the search. We see that already 5 different squares are filled in (the green and red ones). The green ones are some obvious plays but we were actually surprised when it played the red one. The other green ones are 'easy' because for example for the (9,9) example you see that this position is obviously the only place 6 can be played because of the other sixes. But for the red one we don't see a single other 8 on the board and yet it knew that it had to play an 8 there. We have to admit though that our system is a bit flawed since this heuristic cannot be used during the search since too many calculations are made. For example with everything we have filled in we could deduct that for the yellow square, 5 is the only possible play. But this is not feasible since it is way to slow to calculate this. This is why we ordered the domain according to likelihood. If we look at the domain of (2,1) sorted with likelihood, we see that the domain is [5, 3, 6, 8, 9]. So even though we're not fully sure that the 5 had to come there before we filled in the 4 in our block, our system captures the likelihood of a 5 at (2,1) still quite well. Sadly enough this heuristic doesn't really improve the search a lot.

\newpage
\subsubsection{Heuristics our viewpoint}
For our viewpoint it was a bit more difficult to find a heuristic and in fact we weren't really able to find a heuristic for it. The only thing that we found obvious to do is to make the domains smaller when we played a number.
\begin{figure}[h!]
\centering
\includegraphics[width=0.8\textwidth]{smartremoval}
\caption{Smart domain changes}
\label{fig:smart_domain}
\end{figure}
Let's say we want to play a 3 at the green square on figure \ref{fig:smart_domain}. Our initial domain would be from 1 to 9. If we play the 3 in the green square then we know that for all our other 3's that we cannot put them in the first column anymore. So the other domains for playing 3 will remove the first column from their domain. But this play actually contains more information which we try to exploit with our system. Since we played in the first column, we know that for the other 3's in this block row they cannot be played anywhere in block 1 anymore! So for their domain, instead of just removing the first column, we remove all the columns from the first block from their domain! This means that from 9 values we go to 6 immediately and if we play another 3 in this block row then the last 3 only has a search space of 3 left! By doing this small change we effectively speed up our system quite a bit. Before implementing this we recorded a time of 32s for one of our test boards, with these domain adjustments we went to 14s! So we effectively made our system at least twice as fast with this.
\mychapter{2}{Part 2: Hashiwokakero}
\label{sec:Hashiwokakero}
\section{ECLiPSe}
\subsection{Optimization}
Optimization for 4 in corner, 6 at one of the sides or 8 on the board is already fixed implicitly by the
%        [N, E, S, W] #:: 0..2,
%            N + E + S + W #= Amount
(see comments). Single neighbor is also already fixed.
\section{CHR}
\subsection{Optimization}
\mychapter{3}{Conclusion}
\section{Weak points}
\section{Strong points}
\section{Lessons learned}
Never use this system ever again.
\mychapter{4}{Appendix}
We started working on this project before the easter holiday. During our start we often lost quite some time since we didn't really know how the systems worked. During the second week of the easter holiday we continued to work on the project each evening and we finished the Sudoku part at the end of the holiday. We then had to pause our work since we had an enormous deadline for an other course so sadly enough we could only continue working on the project after this deadline (10th may). As the semester was coming to an end other deadlines also started to come closer and closer so we had to manage these first, so it is only at the start of the study period that we could continue our work. From the start of the study period we tried to spend around 6 hours of work each day for this project. The work was not really divided since we were doing pair programming most of the time. Sometimes someone made some individual changes when they had time but most of our work has been made in group over hangouts by using screensharing. We could argue that by doing pair programming we lost quite some time, which is true, but by doing this we worked very closely together and we learned quite a lot.  

\end{document}
