\documentclass{report}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{titlesec}
\usepackage[tmargin=2.0cm, lmargin=4cm, rmargin=4cm]{geometry}
\usepackage{listings}             % Include the listings-package
\usepackage{textcomp}
\usepackage{listings}
%\usepackage{minted}      % (requires -shell-escape)
\usepackage{xcolor}
\usepackage{filecontents}
\usepackage{array}
\usepackage{multirow}
\usepackage{hyperref}
\usepackage{subfig}

\newcolumntype{L}{>{\centering\arraybackslash}m{3cm}}

% --- ugly internals for language definition ---
%
\makeatletter

% initialisation of user macros
\newcommand\PrologPredicateStyle{}
\newcommand\PrologVarStyle{}
\newcommand\PrologAnonymVarStyle{}
\newcommand\PrologAtomStyle{}
\newcommand\PrologOtherStyle{}
\newcommand\PrologCommentStyle{}

% useful switches (to keep track of context)
\newif\ifpredicate@prolog@
\newif\ifwithinparens@prolog@

% save definition of underscore for test
\lst@SaveOutputDef{`_}\underscore@prolog

% local variables
\newcount\currentchar@prolog

\newcommand\@testChar@prolog%
{%
  % if we're in processing mode...
  \ifnum\lst@mode=\lst@Pmode%
    \detectTypeAndHighlight@prolog%
  \else
    % ... or within parentheses
    \ifwithinparens@prolog@%
      \detectTypeAndHighlight@prolog%
    \fi
  \fi
  % Some housekeeping...
  \global\predicate@prolog@false%
}

% helper macros
\newcommand\detectTypeAndHighlight@prolog
{%
  % First, assume that we have an atom.
  \def\lst@thestyle{\PrologAtomStyle}%
  % Test whether we have a predicate and modify the style accordingly.
  \ifpredicate@prolog@%
    \def\lst@thestyle{\PrologPredicateStyle}%
  \else
    % Test whether we have a predicate and modify the style accordingly.
    \expandafter\splitfirstchar@prolog\expandafter{\the\lst@token}%
    % Check whether the identifier starts by an underscore.
    \expandafter\ifx\@testChar@prolog\underscore@prolog%
      % Check whether the identifier is '_' (anonymous variable)
      \ifnum\lst@length=1%
        \let\lst@thestyle\PrologAnonymVarStyle%
      \else
        \let\lst@thestyle\PrologVarStyle%
      \fi
    \else
      % Check whether the identifier starts by a capital letter.
      \currentchar@prolog=65
      \loop
        \expandafter\ifnum\expandafter`\@testChar@prolog=\currentchar@prolog%
          \let\lst@thestyle\PrologVarStyle%
          \let\iterate\relax
        \fi
        \advance \currentchar@prolog by 1
        \unless\ifnum\currentchar@prolog>90
      \repeat
    \fi
  \fi
}
\newcommand\splitfirstchar@prolog{}
\def\splitfirstchar@prolog#1{\@splitfirstchar@prolog#1\relax}
\newcommand\@splitfirstchar@prolog{}
\def\@splitfirstchar@prolog#1#2\relax{\def\@testChar@prolog{#1}}

% helper macro for () delimiters
\def\beginlstdelim#1#2%
{%
  \def\endlstdelim{\PrologOtherStyle #2\egroup}%
  {\PrologOtherStyle #1}%
  \global\predicate@prolog@false%
  \withinparens@prolog@true%
  \bgroup\aftergroup\endlstdelim%
}

% language name
\newcommand\lang@prolog{Prolog-pretty}
% ``normalised'' language name
\expandafter\lst@NormedDef\expandafter\normlang@prolog%
  \expandafter{\lang@prolog}

% language definition
\expandafter\expandafter\expandafter\lstdefinelanguage\expandafter%
{\lang@prolog}
{%
  language            = Prolog,
  keywords            = {},      % reset all preset keywords
  showstringspaces    = false,
  linewidth			  = 15.5cm,
  numbers			   =left,
  alsoletter          = (,
  alsoother           = @\$,
  %moredelim           = **[is][\beginlstdelim{(}{)}]{(}{)},
  MoreSelectCharTable =
    \lst@DefSaveDef{`(}\opparen@prolog{\global\predicate@prolog@true\opparen@prolog},
}

% Hooking into listings to test each ``identifier''
\newcommand\@ddedToOutput@prolog\relax
\lst@AddToHook{Output}{\@ddedToOutput@prolog}

\lst@AddToHook{PreInit}
{%
  \ifx\lst@language\normlang@prolog%
    \let\@ddedToOutput@prolog\@testChar@prolog%
  \fi
}

\lst@AddToHook{DeInit}{\renewcommand\@ddedToOutput@prolog{}}

\makeatother
%
% --- end of ugly internals ---


% --- definition of a custom style similar to that of Pygments ---
% custom colors
\definecolor{PrologPredicate}{RGB}{000,031,255}
\definecolor{PrologVar}      {RGB}{024,021,125}
\definecolor{PrologAnonymVar}{RGB}{000,127,000}
\definecolor{PrologAtom}     {RGB}{186,032,032}
\definecolor{PrologComment}  {RGB}{063,128,127}
\definecolor{PrologOther}    {RGB}{000,000,000}

% redefinition of user macros for Prolog style
\renewcommand\PrologPredicateStyle{\color{PrologPredicate}}
\renewcommand\PrologVarStyle{\color{PrologVar}}
\renewcommand\PrologAnonymVarStyle{\color{PrologAnonymVar}}
\renewcommand\PrologAtomStyle{\color{PrologAtom}}
\renewcommand\PrologCommentStyle{\itshape\color{PrologComment}}
\renewcommand\PrologOtherStyle{\color{PrologOther}}

% custom style definition
\lstdefinestyle{Prolog-pygsty}
{
  language     = Prolog-pretty,
  upquote      = true,
  stringstyle  = \PrologAtomStyle,
  commentstyle = \PrologCommentStyle,
  literate     =
    {:-}{{\PrologOtherStyle :-}}2
    {,}{{\PrologOtherStyle ,}}1
    {.}{{\PrologOtherStyle .}}1
}

% global settings
\lstset
{
  captionpos = below,
  frame      = single,
  breaklines          = true,
  %postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow\space}},
  columns    = fullflexible,
  basicstyle = \ttfamily,
}

%\titlespacing*{\chapter}{0pt}{-19pt}{18pt}

%\title{APLAI}
%\author{thierryderuyttere }
%\date{May 2017}
\newcommand{\mychapter}[2]{
    \setcounter{chapter}{#1}
    \setcounter{section}{0}
    \chapter*{#2}
    \addcontentsline{toc}{chapter}{#2}
}
% \topskip 50pt
%\titlespacing*{\mychapter}{0cm}{-50pt}{0pt}[0pt]

\begin{document}
\lstset{language=Prolog}          % Set your language (you can change the language for each code-block optionally)

\begin{titlepage}
	\newpage
	\thispagestyle{empty}
	\frenchspacing
	\hspace{-0.2cm}
	\includegraphics[height=3.4cm]{sedes}
	\hspace{0.2cm}
	\rule{0.5pt}{3.4cm}
	\hspace{0.2cm}
	\begin{minipage}[b]{8cm}
		\Large{Katholieke\newline Universiteit\newline Leuven}\smallskip\newline
		\large{}\smallskip\newline
		\textbf{Department of\newline Computer Science}\smallskip
	\end{minipage}
	\hspace{\stretch{1}}
	\vspace*{3.2cm}\vfill
	\begin{center}
		\begin{minipage}[t]{\textwidth}
			\begin{center}
				\LARGE{\rm{\textbf{\uppercase{Project}}}}\\
				\Large{\rm{Advanced Programming Languages for A.I. (H02A8a) }}\\
				\vspace{0.5cm}

			    \large{\textsc{Deruyttere-Halilovic}}%

			\end{center}
		\end{minipage}
	\end{center}
	\vfill
	\hfill\makebox[8.5cm][l]{%
		\vbox to 7cm{\vfill\noindent
				{\rm \textbf{Thierry Deruyttere (r0660485)}}\\
				{\rm \textbf{Armin Halilovic (r0679689)}}\\[2mm]
				{\rm Academic year 2016-2017}

		}
	}
\end{titlepage}

\newpage
\tableofcontents
\newpage

\mychapter{0}{Introduction}

In this report we discuss different solvers we have created for Sudoku and Hashiwokakero puzzles. They are the result of a lot of work and a lot of backtracking on our previously done work. We often came in situations where we got stuck because of the limitations of the ECLiPSe and CHR systems but we also often had to backtrack on our work since we often felt that we were doing things in a non-declarative way. We often tried to do things in a procedural way, which means we lost quite some time rethinking how we could write things in a more declarative way.
	\newline
	\newline
	For the solvers we decided to only use ECLiPSe and CHR. This was partially due to the fact that when we started this assignment we still hadn't seen Jess in class. Once we did have the lecture on Jess, we felt that since we were still novices at declarative programming languages, it would be a good exercise to continue using the more declarative systems to gain more experience with them, since Jess can also be used to program in a more procedural way. Another reason for not using Jess was that the Jess syntax looked less appealing than the syntax CHR was offering us with all the parentheses used in its syntax.

\mychapter{1}{Task 1: Sudoku}
\section{Alternative Viewpoint}
\label{sec:other_viewpoint}
For the alternative viewpoint in Sudoku we decided to use the following representation. Each possible sudoku number must occur in N positions which are represented as tuples (X,Y) (with N the size of the sudoku board). Therefore, we keep track of arrays of length N for each possible sudoku number. The arrays hold positions on which the numbers occur. Each of these positions (X,Y) can only be used once by any of the numbers. Within one such array, all of the X's and all of the Y's must be different, so that a number does not occur multiple times on a row or column on the board. In the arrays, we use the indices to represent the different X values. The values at those indices represent the Y values of positions. These values are the search variables in this viewpoint.
\newline
\newline

\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{blockRow}
\caption{Illustration of the definition of a block row}
\end{figure}

The block constraints can be expressed with a bit of maths using this representation. For a specific number, we already know each X of all of the different positions, so we can check in which block row (see illustration) the position is. First, we can split the board up in block rows. For example, if you take a 9x9 board like in the illustration above, you know that rows 1,2,3 belong to block row 1, rows 4,5,6 belongs to block row 2 and rows 7,8,9 belongs to block row 3. To express the block constraints we do the following:
\begin{enumerate}
	\item Take all the positions of a number
	\item Check which positions are in the same block row (there are exactly $\sqrt{N}$ positions of a number in the same block row).
	\item Express that each position in the same block row should be in a different block in that block row.
\end{enumerate}

\section{Criteria to judge if a viewpoint is good or not}
This is really difficult, since we had some trouble at first to find a good alternative viewpoint. We believe that the following criteria can be used to judge whether a viewpoint is good or not.
\begin{itemize}
    \item Ease of expressing what is needed with the viewpoint. Obviously, if you lose a lot of time implementing a viewpoint then it may be worth it to look for an alternative viewpoint.
    \item How easy is it to understand the viewpoint? In other words, is it a logical representation for the problem?
    \item Lastly, think about the amount of constraints necessary with the viewpoint. Is it the lowest amount possible?
\end{itemize}.

\section{Channeling}
The channeling constraint for the two viewpoints, the classical one and the one explained above, are in fact not that hard to express in words. If in the classical viewpoint you know which value there has to be at a certain (X,Y) position, you can immediately set the position in the array of the value in the alternative viewpoint. For the alternative viewpoint, if you know an (X,Y) value for a number, then you can enter the number at that position in the classic viewpoint. This of course is trivial in words but finding the correct way to express it in ECLiPSe was not that straightforward.

\subsubsection{ECLiPSe channeling constraints}
\lstinputlisting[ language = Prolog-pretty, caption  = {Channel constraints in ECLiPSe} ]{eclipse_channel.pl}
%The first two lines of code are just to get the size of the Board and NumberPositions. Note that both of them are $N x N$, only NumberPositions has an extra dimension to store the (X,Y) pairs.
%After this we create the loop variables Number, Positions and Y, these will be used for the channeling constraint and they start from 1 to N.
The crucial bit of code for the channeling constraints are inside the multifor. There you can see two different constraints that links the two viewpoints together. The first one is the channeling constraint for the classical viewpoint. It lays a constraint on the value of Board[X, Y]. The second constraint is the channeling constraint for the alternative viewpoint. There you can see that we index with \texttt{Number} and \texttt{X}. Together these constraints expresses that if Y is known in the alternative viewpoint then we can fill in Board[X, Y] with \texttt{Number} or if we know which number is at [X, Y] in the classic viewpoint then we can fill in the Y of the alternative viewpoint. This is done with the B at the end of both of the constraints. This B is crucial in the channeling constraints as it expresses that if one of the constraints is true, then the other should be true as well.

\newpage
\subsubsection{CHR channeling constraints}
\lstinputlisting[ language = Prolog-pretty, caption  = {Channel constraints in CHR} ]{chr_channel.pl}
For the channeling constraints in CHR we decided to use an extra predicate \texttt{channel}. This is used just so that the solver sets up the channel constraints at the right moment. Expressing the channeling constraints in CHR was a bit easier than doing it in ECLiPSe. The first rule expresses that if Value of board and board\_viewpoint2 are the same, and if Value is a number, and if Y2 and B2 are still variables then we can say that Y2 equals Y and B2 equals BlockIndex. The important part here was that Y2 and B2 are still variables since this means that we don't know their values yet. Why do we initialise Y2 and B2 instead of just removing the old board\_viewpoint2 from the constraint store? If we would just remove board\_viewpoint2 then this would mean that other constraints would never be fired! When Y2 and B2 get their values, other rules which could not be fired before might be fired now.
\newline
\newline
For the second constraint we need to know that both Y and BlockIndex are numbers and V2 is a free variable. Since we know both Y and BlockIndex, we can just fill in the Value of that position in board.
\newpage
\section{Experiments}
\subsection{ECLiPSe}
\subsubsection{input order as value heuristic, alldifferent from ic\_global}
\begin{table}[h!]
  \begin{tabular}{|c|c|c|c|c|c|c|}
    \hline
    \multirow{2}{*}{Puzzle} &
    \multicolumn{2}{L|}{Classical Viewpoint} &
    \multicolumn{2}{L|}{Alternative viewpoint} &
    \multicolumn{2}{L|}{Channeling} \\
    & s & backtracks & s & backtracks & s & backtracks \\
    \hline
        lambda & 0.01 & 3 & 74.669 & 78859 & 0.031 & 2\\
        hard17 & 0.01 & 1 & 84.319 & 130134 & 0.041 & 0\\
        eastermonster & 0.21 & 51 & 3.29 & 3278 & 0.139 & 24\\
        tarek\_052 & 0.34 & 59 & 0.19 & 166 & 0.03 & 0\\
        goldennugget & 0.671 & 104 & 12.79 & 11171 & 0.63 & 70\\
        coloin & 0.22 & 88 & 6.469 & 4717 & 1.071 & 178\\
        extra2 & 0.0 & 0 & 691.25 & 662099 & 0.05 & 4\\
        extra3 & 0.011 & 3 & 70.23 & 78859 & 0.03 & 2\\
        extra4 & 0.01 & 4 & 174.23 & 197306 & 0.03 & 3\\
        inkara2012 & 0.03 & 3 & 4.23 & 5273 & 0.19 & 34\\
        clue18 & 0.26 & 69 & 162.28 & 156554 & 0.17 & 20\\
        clue17 & 0.01 & 0 & 180.65 & 191972 & 0.01 & 0\\
        sudowiki\_nb28 & 1.03 & 413 & 39.82 & 40477 & 3.36 & 832\\
        sudowiki\_nb49 & 0.19 & 48 & 9.86 & 10771 & 0.2 & 37\\
    \hline
  \end{tabular}
\end{table}

\subsubsection{input order as value heuristic, alldifferent from ic}
\begin{table}[h!]
  \begin{tabular}{|c|c|c|c|c|c|c|}
    \hline
    \multirow{2}{*}{Puzzle} &
    \multicolumn{2}{L|}{Classical Viewpoint} &
    \multicolumn{2}{L|}{Alternative viewpoint} &
    \multicolumn{2}{L|}{Channeling} \\
    & ms & backtracks & ms & backtracks & ms & backtracks \\
    \hline
        lambda & 0.34 & 4712 & 36.93 & 99470 & 1.359 & 1155\\
        hard17 & 0.07 & 873 & 53.289 & 153383 & 0.781 & 1187\\
        eastermonster & 0.01 & 119 & 2.709 & 4361 & 0.131 & 85\\
        tarek\_052 & 0.02 & 193 & 0.15 & 201 & 0.01 & 6\\
        goldennugget & 0.06 & 520 & 8.81 & 16938 & 0.42 & 389\\
        coloin & 0.19 & 2209 & 3.82 & 6998 & 0.76 & 676\\
        extra2 & 0.18 & 4652 & 477.78 & 959808 & 6.57 & 13979\\
        extra3 & 0.33 & 4712 & 34.6 & 99470 & 1.21 & 1155\\
        extra4 & 0.95 & 15116 & 89.85 & 253873 & 1.19 & 1540\\
        inkara2012 & 0.0 & 50 & 3.78 & 8033 & 0.26 & 196\\
        clue18 & 0.14 & 1838 & 118.8 & 268974 & 3.19 & 3604\\
        clue17 & 0.33 & 5520 & 98.43 & 227622 & 0.15 & 177\\
        sudowiki\_nb28 & 0.21 & 2851 & 41.91 & 76081 & 2.33 & 2187\\
        sudowiki\_nb49 & 0.11 & 1078 & 5.89 & 14424 & 0.18 & 232\\
    \hline
  \end{tabular}
\end{table}

\newpage
\subsubsection{first fail as value heuristic, alldifferent from ic\_global}

\begin{table}[h!]
  \begin{tabular}{|c|c|c|c|c|c|c|}
    \hline
    \multirow{2}{*}{Puzzle} &
    \multicolumn{2}{L|}{Classical Viewpoint} &
    \multicolumn{2}{L|}{Alternative viewpoint} &
    \multicolumn{2}{L|}{Channeling} \\
    & ms & backtracks & ms & backtracks & ms & backtracks \\
    \hline
        lambda & 0.02 & 3 & 24.07 & 32384 & 0.03 & 2 \\
        hard17 & 0.01 & 1 & 6.28 & 9183 & 0.02 & 0 \\
        eastermonster & 0.12 & 33 & 10.69 & 11599 & 0.17 & 25 \\
        tarek\_052 & 0.16 & 35 & 1.389 & 1502 & 0.071 & 6 \\
        goldennugget & 0.29 & 76 & 19.94 & 19870 & 0.39 & 59 \\
        coloin & 0.04 & 8 & 0.48 & 527 & 0.32 & 56 \\
        extra2 & 0.0 & 0 & 0.68 & 909 & 0.02 & 0 \\
        extra3 & 0.01 & 3 & 23.88 & 32384 & 0.03 & 2 \\
        extra4 & 0.01 & 3 & 585.84 & 858267 & 0.03 & 3 \\
        inkara2012 & 0.08 & 17 & 8.33 & 10942 & 0.08 & 15 \\
        clue18 & 0.04 & 8 & 175.63 & 221669 & 0.02 & 0 \\
        clue17 & 0.01 & 0 & 262.53 & 336082 & 0.019 & 0 \\
        sudowiki\_nb28 & 0.549 & 297 & 41.25 & 46872 & 1.25 & 344 \\
        sudowiki\_nb49 & 0.21 & 58 & 23.021 & 24536 & 0.219 & 38 \\
    \hline
  \end{tabular}
\end{table}

\subsubsection{first fail as value heuristic, alldifferent from ic}
\begin{table}[h!]
  \begin{tabular}{|c|c|c|c|c|c|c|}
    \hline
    \multirow{2}{*}{Puzzle} &
    \multicolumn{2}{L|}{Classical Viewpoint} &
    \multicolumn{2}{L|}{Alternative viewpoint} &
    \multicolumn{2}{L|}{Channeling} \\
    & ms & backtracks & ms & backtracks & ms & backtracks \\
    \hline
        lambda & 0.091 & 977 & 10.42 & 36846 & 1.2 & 1961 \\
        hard17 & 0.031 & 419 & 7.06 & 23036 & 0.139 & 386 \\
        eastermonster & 0.01 & 101 & 6.71 & 16122 & 0.11 & 122 \\
        tarek\_052 & 0.019 & 130 & 1.11 & 3178 & 0.05 & 45 \\
        goldennugget & 0.051 & 358 & 9.609 & 23741 & 0.261 & 310 \\
        coloin & 0.01 & 83 & 0.29 & 929 & 0.22 & 227 \\
        extra2 & 0.49 & 7690 & 0.3 & 1044 & 0.0 & 10 \\
        extra3 & 0.08 & 977 & 10.89 & 36846 & 1.34 & 1961 \\
        extra4 & 0.19 & 2097 & 289.22 & 986497 & 0.32 & 720 \\
        inkara2012 & 0.03 & 273 & 5.36 & 13509 & 0.09 & 108 \\
        clue18 & 0.05 & 439 & 88.58 & 256741 & 0.06 & 52 \\
        clue17 & 0.03 & 270 & 140.96 & 440342 & 0.01 & 15 \\
        sudowiki\_nb28 & 0.21 & 2221 & 20.19 & 60024 & 0.65 & 864 \\
        sudowiki\_nb49 & 0.07 & 655 & 11.9 & 32895 & 0.19 & 241 \\
    \hline
  \end{tabular}
\end{table}
\newpage
\subsection{Impact of the different search strategies and alldifferent}
\subsubsection{Input order vs first fail}
When we compare the two tables for \texttt{input order} and \texttt{first fail} with the alldifferent from ic\_global we see that actually for most of the puzzles in all the three columns, the \texttt{first fail} heuristic does a better job than \texttt{input order}. We can see that there sometimes are large differences between the two tables. For example, 'extra2' for the alternative viewpoint in the \texttt{input order} table has 662k backtracks but when you look over at the \texttt{first fail} table you see that it only has 909 backtracks! Though, it is not always \texttt{first fail} that is faster. If we look at 'extra4' for the alternative viewpoint we see that \texttt{input order} is faster this time! 197306 backtracks for \texttt{input order} vs 858267 backtracks for \texttt{first fail}. This is quite odd, since 'extra4' is just puzzle 'extra3' (where \texttt{first fail} outperforms \texttt{input order} by more than 50\%) with an extra hint.
\newline
\newline
When we look at the tables where we use alldifferent from the ic, we see exactly the same behavior as mentioned before. We see that most of the times \texttt{first fail} is faster than \texttt{input order} but yet again we observe the same odd behavior for 'extra4'.

\subsubsection{ic\_global vs ic}
When we compare the alldifferent from ic\_global vs ic we see that the version from ic\_global is faster/does less backtracking! For the alternative viewpoint, the increase is not that big but when you look at the channeling column and the classical viewpoint, then you see that the increases in backtracks here are quite big!

\subsection{Analysis of differences}
\subsubsection{input order vs first fail}
To be able to explain these behaviors, we first have to know the exact difference between the two search strategies. \texttt{Input order} takes the first domains that has been created, while \texttt{first fail} starts from the smallest domain. We think that the difference for 'extra4' can explained as follows: As you always take the smallest domain, if you make a wrong decision early on, you will need to do a lot of backtracks in a wrong branch of the tree. Since you always took the smallest ones first you get a tree branch that is very wide. If your first choice was a mistake you need to traverse this whole subtree first before you can backtrack to your first choice. We believe that the extra hint resulted in this situation. It has probably reduced a domain which creates these problems. \texttt{Input order} doesn't suffer from this since it just takes the first entered domains. On the other hand, sometimes taking the smallest domain gives you the best result because you have less choices to make here, which would explain the behavior for 'extra2'.

\subsubsection{alldifferent}
The difference with the alldifferent versions is due to the fact that the alldifferent from ic\_global has been programmed with stronger propagation behavior \footnote{\url{http://eclipseclp.org/doc/bips/lib/ic\_global/alldifferent-1.html}} than the alldifferent from the ic library as explained in class. The ic\_global implementation has a global view of the constraints and can thus make smarter decisions about it.

\newpage
\subsection{CHR}
\label{sub:CHR}

For the CHR implementation of the two viewpoints we had a lot of trouble getting something that performs well. When we run the two viewpoints on harder boards it takes easily a couple of minutes. Obviously this isn't good, so we improved the performance of both our implementations using the heuristics explained below.

\subsubsection{Heuristic classical viewpoint}
For the classical viewpoint we found that there was one obvious heuristic that we could use to try to improve the search. To demonstrate this let's take, for example, the 'lambda' board from the puzzles provided in the assignment.

\begin{figure}[h]
    \centering
    \subfloat[Lambda board]{\label{fig:classic_heuristic_a}{\includegraphics[width=5cm]{lambda1}}}%
    \qquad
    \subfloat[Lambda board after heuristic]{\label{fig:classic_heuristic_b}{\includegraphics[width=5cm]{lambda2} }}%
    \caption{Lambda board pre vs post heuristic}%
\end{figure}
If we look at \ref{fig:classic_heuristic_a} we can see that in position (9,9), the only possible number we can play there is a 6, since it cannot be put anywhere else in the block because of the two sixes of the neighboring blocks. This information is critical to be able to solve sudoku puzzles in a smarter way. This is what we tried to do with our likelihood heuristic. Our heuristic will state that it is very likely that 6 should be put on position (9,9). In fact it is 100\% 'likely' that 6 should be played there.
\newline
\newline
\newline
The way we do this is by checking the domain of (9,9) and comparing it with to the domains of all the other squares in the block. When doing this comparison, we check for the numbers that are in our domain but not in the domain of the square we're comparing with. If a number is not present in the domain of the other square, e.g. number 6, then we know that the likelihood that this 6 is at our position increases. Thus, we keep track of all the differences between the other squares and we count how many times we've seen a number. We then sort our domain according to this in a descending order based on the count. Obviously, we want to try things that are very likely first and things that are less likely at a later moment. One important observation to this is that if the count of a number equals to 9, you know that we are in the only position that can play this number else we would never see this number appear 8 times from the differences. We get to 9 because we use our domain as a starting point. This means that each number in our domain immediately gets a count of 1. We do this because it is not certain that when checking all the differences with the other squares, that you will get all the values from your domain. So if we would only use the numbers from the differences we might for example never see a 2 while actually 2 was the only answer that could be played at that position in the end.
\newline
\newline
When we look at figure \ref{fig:classic_heuristic_b} , we can see the effect of our likelihood heuristic just before the start of the search. We see that already 5 different squares are filled in (the green and red ones). The green ones are some obvious plays but we were actually surprised when it found the red one. The other green ones are 'easy' because for the (9,9) example you see that this position is obviously the only place a 6 can be played because of the other sixes. But for the red one we don't see a single other 8 on the board and yet it knew that it had to play an 8 there. We have to admit though that our system is a bit flawed since this heuristic cannot be used during the search since too many calculations are made. For example with everything we have filled in, we could deduct that for the yellow square, 5 is the only possible play. But this is not feasible since it is way to slow to calculate this. This is why we ordered the domain according to likelihood. If we look at the domain of (2,1) sorted with likelihood, we see that the domain is [5, 3, 6, 8, 9]. So even though we're not fully sure that the 5 had to come there before we filled in the 4 in our block, our system captures the likelihood of a 5 at (2,1) still quite well.

\subsubsection{Heuristic alternative viewpoint}
To increase the search speed for the alternative viewpoint we decided to do something about the search space itself. Consider the following example:
\begin{figure}[h!]
\centering
\includegraphics[width=0.8\textwidth]{smartremoval}
\caption{Smart domain changes}
\label{fig:smart_domain}
\end{figure}
Let's say we want to play a 3 at the green square on figure \ref{fig:smart_domain}. Our initial domain would be from 1 to 9. If we play the 3 in the green square, then we know that we cannot put aby other 3's in the first column. So the in the domains of other 3's, the first column is removed. But this play actually contains more information which we try to exploit here. Since we played in the first column, we know that the other 3's in this block row cannot be played anywhere in block 1 anymore! So for their domains, instead of just removing the first column, we remove all the columns in the first block. This means that from 9 values, we go to 6, and if we play another 3 in this block row, then the last 3 only has a search space of 3 left! By doing this small change we effectively speed up our system quite a bit.
\subsubsection{Experiments}
%%% OLD
%\begin{table}[h!]
%  \begin{tabular}{|c|c|c|c|c|c|c|}
%    \hline
%    \multirow{1}{*}{Puzzle} &
%    \multicolumn{1}{L|}{Classical Viewpoint} &
%    \multicolumn{1}{L|}{Alternative viewpoint} &
%    \multicolumn{1}{L|}{Channeling} \\
%    & s & s & s \\
%    \hline
%        lambda & 340.04 & 118.72 & 218.44 \\
%        hard17 & 2003.50 & 463.11 & 413.61 \\
%        eastermonster & 63.57 & 235.10 & 32.77 \\
%        tarek\_052 & 13.58 & 170.76 & 26.12 \\
%        goldennugget & 18.151 & 155.49 & 21.42 \\
%        coloin & 132.72 & 74.82 & 69.82 \\
%        extra2 & 18.92 & 2444.10 & 14.14 \\
%        extra3 & 372.84 & 134.93 & 233.17 \\
%        extra4 & 141.55 & 297.64 & 115.41 \\
%        inkara2012 & 141.58 & 1220.32 & 116.46 \\
%        % ik heb het veranderd naar 45min want hard17 met 2000s is > 30min
%        clue18 & aborted after 45min & aborted after 45min & aborted after 45min \\
%        clue17 & 11.29 & 563.06 & 8.56s \\
%        sudowiki\_nb28& 446.24 & 45.05 & 237.02s \\
%        sudowiki\_nb49 & 73.02 & 69.20 & 68.67s \\
%    \hline
%  \end{tabular}
%  \caption{Sudoku in CHR without heuristics}
%\end{table}
%NEW %%%
\begin{table}[h!]
      \begin{tabular}{|c|c|c|c|c|c|c|}
        \hline
        \multirow{1}{*}{Puzzle} &
          \multicolumn{1}{L|}{Classical Viewpoint} &
          \multicolumn{1}{L|}{Alternative viewpoint} &
          \multicolumn{1}{L|}{Channeling} \\
        & s & s & s \\
        \hline
lambda & 240.556s & 31.546s & 268.08s \\
hard17 & 1410.554s & 111.446s & 581.685s \\
eastermonster & 2.626s & 52.918s & 3.78s \\
tarek\_052 & 9.705s & 47.722s & 19.056s \\
goldennugget & 13.731s & 40.311s & 20.638s \\
coloin & 92.932s & 21.009s & 99.832s \\
extra2 & 14.038s & 553.181s & 19.242s \\
extra3 & 235.877s & 31.142s & 269.242s \\
extra4 & 91.517s & 69.132s & 128.158s \\
inkara2012 & 92.476s & 294.721s & 114.792s \\
clue18 & 1854.41s & 1373.993s & 2743.256s \\
clue17 & 6.168s & 142.121s & 9.855s \\
sudowiki\_nb28 & 289.829s & 11.816s & 278.37s \\
sudowiki\_nb49 & 47.434s & 14.049s & 64.556s \\
 \hline
      \end{tabular}
        \caption{Sudoku in CHR without heuristics}

    \end{table}
    
\begin{table}[h!]
      \begin{tabular}{|c|c|c|c|c|c|c|}
        \hline
        \multirow{1}{*}{Puzzle} &
          \multicolumn{1}{L|}{Classical Viewpoint} &
          \multicolumn{1}{L|}{Alternative viewpoint} &
          \multicolumn{1}{L|}{Channeling} \\
        & s & s & s \\
        \hline
lambda & 294.197s & 4.47s & 141.152s \\
hard17 & 218.107s & 0.225s & 30.291s \\
eastermonster & 52.796s & 11.054s & 31.252s \\
tarek\_052 & 1.351s & 56.398s & 1.81s \\
goldennugget & 16.791s & 26.212s & 18.233s \\
coloin & 67.885s & 25.439s & 46.873s \\
extra2 & 360.367s & 37.646s & 26.468s \\
extra3 & 277.144s & 4.452s & 143.193s \\
extra4 & 128.014s & 5.107s & 65.539s \\
inkara2012 & 7.399s & 161.194s & 7.062s \\
clue18 & 774.288s & 312.615s & 479.363s \\
clue17 & 16.193s & 0.534s & 7.414s \\
sudowiki\_nb28 & 994.815s & 3.527s & 477.672s \\
sudowiki\_nb49 & 103.807s & 14.097s & 112.585s \\
 \hline
      \end{tabular}
      \caption{Sudoku in CHR with heuristics}
    \end{table}

%\begin{table}[h!]
%  \begin{tabular}{|c|c|c|c|c|c|c|}
%    \hline
%    \multirow{1}{*}{Puzzle} &
%    \multicolumn{1}{L|}{Classical Viewpoint} &
%    \multicolumn{1}{L|}{the alternative viewpoint} &
%    \multicolumn{1}{L|}{Channeling} \\
%    & s & s & s \\
%    \hline
%        lambda & 383.27 & 8.07 & 70.85s \\
%        hard17 & 282.39 & 0.30 & 1.61s \\
%        eastermonster & 68.83 & 14.74 & 16.73s \\
%        tarek\_052 & 1.70 & 90.21 & 1.70s \\
%        goldennugget & 24.11 & 43.1 & 13.81s \\
%        coloin & 90.63 & 42.73 & 17.73s \\
%        extra2 & 486.39 & 54.98 & 2.11s \\
%        extra3 & 385.02 & 7.95 & 70.63s \\
%        extra4 & 184.18 & 10.60 & 46.23s \\
%        inkara2012 & 10.75 & 255.18 & 5.50s \\
%        clue18 & 1068.80 & 569.44 & 249.05s \\
%        clue17 & 25.60 & 1.01 & 0.98s \\
%        sudowiki\_nb28 & 1204.91 & 4.58 & 207.25s \\
%        sudowiki\_nb49 & 130.41 & 21.85 & 70.93s \\
%    \hline
%  \end{tabular}
%  \caption{Sudoku in CHR with heuristics}
%\end{table}
When we compare both tables, we see that for the alternative viewpoint there is a good improvement. Although when we look at the impact of the heuristic for the classic viewpoint, we see that it is in most cases quite a bit slower! However, for the harder boards like hard17 and clue18 we can see a big speed up! The impact of channeling here can be seen in the last column. Sometimes it does bring a serious improvement compared to a standalone technique. Sometimes it is even worse than the two techniques separately for example clue18 in the table without heuristics. We we look to the table with heuristics however we see that there has been a very big increase in speed for clue18!
\mychapter{2}{Task 2: Hashiwokakero}
\label{sec:Hashiwokakero}

\section{ECLiPSe}

\subsection{Basic solver}
\subsubsection{Constraints}
The ECLiPSe Hashiwokakero solver is based on the stackoverflow post\footnote{\url{https://stackoverflow.com/questions/20337029/hashi-puzzle-representation\_-to-solve-all-solutions-with-prolog-restrictions}} given in the assignment. We have used the proposed data structure and constraints in the post, and have added constraints for the connectivity of the islands. The resulting constraints are:
\begin{itemize}
	\item For every position on the board it holds that the amount of bridges going in one direction (e.g. N) equals the amount of bridges going in the opposite direction (e.g. S) from the next position in the original direction (N in this example). If the position is on an edge of the board, the amount of bridges in the direction that would go outside of the board is zero.

	% This is wrong
	%For every island that is not on any of the borders on the board, a bridge that comes from a certain direction, needs to go out on the opposite direction. This means that any bridge coming from the North also leaves from the South or vice versa. Any bridge coming from the West leaves from the East or vice versa. If following one of the directions would mean that we would leave the board, put a 0 on that direction.
        \lstinputlisting[ language = Prolog-pretty ]{pass_through.pl}

    \item The sum of all bridges connected to an island must be equal to the number of the island.
        \lstinputlisting[ language = Prolog-pretty ]{sum.pl}

    \item The amount of bridges going in one direction equals the amount of bridges going the opposite direction and bridges cannot cross each other.
        \lstinputlisting[ language = Prolog-pretty ]{no_crossing.pl}

    \item The connectivity constraint is implemented by checking that all islands can be visited starting from a certain island. This is done after the search. fill\_set\_visit is called with a certain starting island. Then, the Visited list is filled with the islands that can be reached from the starting island. Afterwards, the length of Visited must equal the amount of islands on the board. If the length of Visited does not equal the amount of islands on the board, this means that not all islands can be visited from a certain island, which then means that the bridges do not connect the islands into a single connected set.
\begin{lstlisting}[ language = Prolog-pretty]
board_connected_set(Board) :-
    board_islands(Board, Islands),
    length(Islands, N),
    length(Visited, N),
    % make the island be member of current set
    nth1(1, Islands, [X, Y]),
    % set position to visited
    nth1(1, Visited, 1),
    % travel to the neighbors of the current position and fill the Islands/Visited set
    fill_set_visit(Board, X, Y, Islands, Visited),
    % if all free variables in Visited have been bound, then all islands form a connected set
    count_nonvars(Visited, N).
\end{lstlisting}

\end{itemize}
All the constraints are active, except for the connectivity constraints. The connectivity constraint does not directly make changes to domains of variables so it a passive constraint. The other constraints do make changes to domains.
\subsection{Improvements}
When one thinks about improvements for solving Hashiwokakero there are a couple of obvious ones that pop up. For example, if there is a 4 in one of the four corners, the only way to get 4 bridges is by placing 2 bridges in the two possible directions. The same idea goes for a 6 at one of the edges of the board. Because one of it's directions is blocked, the only way to get 6 briges is by placing 2 bridges in all 3 of the possible directions. For an island with an 8, the only option is to place 2 bridges in every direction. These seem like good improvements, but actually they were already done implicitly by ECLiPSe's domain solving. Since these were not really improvements to our solver, we had to look for other improvements. The following improvements are inspired by \url{http://www.conceptispuzzles.com/index.aspx?uri=puzzle/hashi/techniques}.

\begin{enumerate}
	\item The first improvement we made was stating that a 1 and another 1 cannot be connected directly to each other. If there was a bridge between them, we would immediately have an invalid solution, as all of the islands in the end result must form a single connected set. Another situation that corresponds with this idea is a 2 and another 2. These can never have 2 bridges between each other since then you would also create an isolated segment. By stating that there cannot be a bridge between islands with 1 and that there cannot be two bridges between islands with 2, we have added more knowledge before the search starts. \\
	Figure \ref{fig:classic_heuristic} shows the result of this improvement. It shows two boards before the search phase. The board with the improvement contains two more briges before the search phase. This means that the during the search less backtracking will occur in the worst case.
	\begin{figure}[h]
    	%\label{fig:improvement1}
        \centering
        \subfloat[board without improvement]{{\includegraphics[width=2cm]{one_to_one_imprv}}}%
        \qquad
        \subfloat[board with improvement]{{\includegraphics[width=2cm]{one_to_one_improv2} }}%
        \caption{boards without and with improvement}%
    \end{figure}

	\item The second improvement builds further on the idea of avoiding isolated segments.
	Assume there is an island with a 2 that has three neighbors, two of which are islands with 1. If you were to place a bridge from the 2 to both of the 1's, then you would end up with an isolated segment. In this case, we know that the third neighbor will have at least one bridge going to the 2. This is implemented by stating that the amount of bridges going from the 2 to the third neighbor cannot be zero. This adds more knowledge to start with before the search.

	\item The third improvement avoids isolated segments for islands with a 3 that have 3 neighbors, among which one neighbor has a 1 and another has a two. If you connect one bridge with the 1 and 2 bridges with the 2, you get an isolated segment. In this case, we know for sure that the third neighbor of the island with 3 has at least one bridge going to the 3. This is implemented by stating that the amount of bridges going from the 3 to the third neighbor cannot be zero. Again, this adds more knowledge to start with before the search.
\end{enumerate}

All three of the improvements have an impact on the connectivity constraint. Because the improvements avoid isolated segments before the search starts, the amount of backtracks (in the wost case) caused to satisfy the connectivity constraint will be reduced.

\subsection{Experiments}

	\begin{figure}[h]
    	%\label{fig:improvement1}
        \centering
        \subfloat[board pre search]{{\includegraphics[width=2.2cm]{board_5_pre}}}%
        \qquad
        \subfloat[board post search]{{\includegraphics[width=2cm]{board_5_post} }}%
        \caption{Some of the boards are ready even before the search (board 5)}%
    \end{figure}
    
\subsubsection{ECLiPSe Hashiwokakero solutions using input order}
Table \ref{table:hashi-1} shows the results of searching with the input order heuristic.
\begin{table}[h!]
\center
  \begin{tabular}{|c|c|c|c|c|}
    \hline
    \multirow{2}{*}{Puzzle} &
    \multicolumn{2}{L|}{Without improvements} &
    \multicolumn{2}{L|}{With improvements}\\
    & ms & backtracks & ms & backtracks \\
    \hline
        1 & 0 & 1 & 0 & 1 \\
        2 & 130 & 60 & 81 & 42 \\
        3 & 0 & 0 & 0 & 0 \\
        4 & 0 & 0 & 0 & 0 \\
        5 & 0 & 0 & 0 & 0 \\
        6 & 10 & 1 & 10 & 1 \\
        7 & 0 & 0 & 0 & 0 \\
        8 & 0 & 0 & 0 & 0 \\
        9 & 0 & 1 & 0 & 1 \\
        10 & 49 & 160 & 61 & 160 \\
        11 & 0 & 0 & 0 & 0 \\
        12 & 0 & 1 & 0 & 1 \\
        13 & 10 & 0 & 0 & 0 \\
        14 & 0 & 1 & 0 & 1 \\
        15 & 20 & 4 & 20 & 4 \\
        16 & 21 & 28 & 20 & 28 \\
        17 & 10 & 1 & 9 & 0 \\
        18 & 0 & 1 & 0 & 1 \\
        19 & 0 & 0 & 0 & 0 \\
        20 & 0 & 2 & 0 & 1 \\
        21 & 0 & 1 & 0 & 0 \\
        22 & 10 & 9 & 10 & 9 \\
    \hline
  \end{tabular}
  \caption{ECLiPSe Hashiwokakero solutions using input order}
  \label{table:hashi-1}
\end{table}

\subsubsection{ECLiPSe Hashiwokakero solutions using first fail}
Table \ref{table:hashi-2} shows the results of searching with the first fail heuristic.
\begin{table}[h!]
\center
  \begin{tabular}{|c|c|c|c|c|}
    \hline
    \multirow{2}{*}{Puzzle} &
    \multicolumn{2}{L|}{Without improvements} &
    \multicolumn{2}{L|}{With improvements}\\
    & ms & backtracks & ms & backtracks \\
    \hline
        1 & 0 & 1 & 0 & 1 \\
        2 & 170 & 61 & 20 & 61 \\
        3 & 0 & 0 &  & 0 \\
        4 & 0 & 0 & 0 & 0 \\
        5 & 0 & 0 &  & 0 \\
        6 & 10 & 1 &  & 1 \\
        7 & 0 & 0 &  & 0 \\
        8 & 0 & 0 &  & 0 \\
        9 & 0 & 1 & 0 & 1 \\
        10 & 110 & 152 & 69 & 152 \\
        11 & 0 & 0 & 0 & 0 \\
        12 & 0 & 1 & 10 & 1 \\
        13 & 0 & 0 & 0 & 0 \\
        14 & 10 & 1 & 0 & 1 \\
        15 & 80 & 4 & 90 & 4 \\
        16 & 50 & 28 & 61 & 28 \\
        17 & 0 & 1 & 10 & 0 \\
        18 & 0 & 1 & 0 & 1 \\
        19 & 0 & 0 & 0 & 0 \\
        20 & 0 & 2 & 0 & 1 \\
        21 & 0 & 1 & 0 & 0 \\
        22 & 10 & 9 & 10 & 9 \\
    \hline
  \end{tabular}
  \caption{ECLiPSe Hashiwokakero solutions using first fail}
  \label{table:hashi-2}
\end{table}

\newpage
\newpage
\section{CHR}
\subsection{Data representation}
We used the same data representation as in the ECLiPSe solution. The data is stored in 'board/7' facts with variables X, Y, Am, N, E, S, W, where (X, Y) represents the position of the board, Am the amount of bridges that must be connected this position. N, E, S, and W represent the amount of bridges that go in a certain direction from position (X,Y).

\subsection{Constraints representation}
\begin{itemize}
	\item The amount of bridges going in one direction equals the amount of bridges going in the opposite direction on the next position.
\begin{lstlisting}[ language = Prolog-pretty]
bridge_constraints, board(X, Y, _, N, _, _, _), board(X2, Y, _, _, _, S, _)
    ==> X > 1, X2 is X-1 |
    N eq S.

bridge_constraints, board(X, Y, _, _, E, _, _), board(X, Y2, _, _, _, _, W)
    ==> Y2 is Y+1 |
    E eq W.
\end{lstlisting}

	\item There are no crossing bridges. In other words, if the amount of bridges going in one direction is greater than zero, then the amount of bridges going in the perpendicular position must be zero.
\begin{lstlisting}[ language = Prolog-pretty]
board(_, _, 0, N, E, _, _) ==> number(N), N > 0 | E = 0.
board(_, _, 0, N, E, _, _) ==> number(E), E > 0 | N = 0.
\end{lstlisting}

\item Bridges cannot go outside of the board. The amount of bridges going in a direction that would leave the board are set to zero here.
\begin{lstlisting}[ language = Prolog-pretty]
bridge_constraints, board(1, _, _, N, _, _, _)                ==> N = 0.
bridge_constraints, board(_, YMax, _, _, E, _, _), ymax(YMax) ==> E = 0.
bridge_constraints, board(XMax, _, _, _, _, S, _), xmax(XMax) ==> S = 0.
bridge_constraints, board(_, 1, _, _, _, _, W)                ==> W = 0.
\end{lstlisting}
\item If on a certain position there is no island, then the amount of bridges that come in from a certain direction equals the amount of bridges that leave in the opposite direction.
\begin{lstlisting}[ language = Prolog-pretty]
bridge_constraints, board(_, _, 0, N, E, S, W) ==> N = S, E = W.
\end{lstlisting}
\item The amount of bridges connected to an island equals that island's amount. Three addition constraints are used here to represent \[ Amount = N + E + S + W \]
\newpage
	    \begin{lstlisting}[ language = Prolog-pretty]
bridge_constraints, board(_, _, Amount, N, E, S, W) ==> Amount > 0 |
    Sum in 0..4,
    Sum2 in 0..4,
    add(N, E, Sum),
    add(S, W, Sum2),
    add(Sum, Sum2, Amount).
\end{lstlisting}
\end{itemize}

\subsection{Propagation and search}
Constraint propagation is handled by the 'in/2', 'add/3' and 'eq/2' rules. The 'in/2' rule is used to set the domain of a variable. The domain of a variable is a list of integers represented by two integers A and B and is noted as 'A..B'. When the domain of a variable only contains one element (when A equals B), then the value of the variable is known. \\
The 'add/3' and 'eq/2' rules are used to represent the rules for addition and equality in the program. additionally, their job is to reduce the domains of variables (see lines 9, 10, and 15 in the code below). This makes these constraints active constraints. An example of the domain reduction goes as follows. Assume the following facts are known. 'X in 0..4', 'Y in 0..4', 'Z in 0..2', add(X, Y, Z). We know that \(X + Y\) must equal \(Z\), and that \(Z\) must lie between 0 and 2. Therefore, we can reduce the domains of \(X\) and \(Y\) from '0..4' to '0..2'. This kind of behaviour is implemented by line 15 in the code excerpt below.
\begin{lstlisting}[ language = Prolog-pretty, caption = {Constraint propagation and domain solving} ]
% remove duplicate indomain constraints
X in A..B \ X in A..B <=> var(X) | true.
% when a variable's domain gets reduced to 1 number, set the value of the variable
X in A..A <=> var(X) | X = A.

% equality constraint
X eq Y <=> number(X), number(Y) | X == Y.
% equality domain constraint solving
X eq Y \ X in A..B, Y in C..D <=> A \== C | L is max(A, C), X in L..B, Y in L..D.
X eq Y \ X in A..B, Y in C..D <=> B \== D | U is min(B, D), X in A..U, Y in C..U.

% addition constraint
add(X, Y, Z) <=> number(X), number(Y), number(Z) | Z is X + Y.
% addition domain constraint solving
add(X, Y, Z) \ X in A..B, Y in C..D, Z in E..F <=>
    not( ( A >= E-D, B =< F-C, C >= E-B, D =< F-A, E >= A+C, F =< B+D ) ) |
        NewA is max(A, E-D), NewB is min(B, F-C), X in NewA..NewB,
        NewC is max(C, E-B), NewD is min(D, F-A), Y in NewC..NewD,
        NewE is max(E, A+C), NewF is min(F, B+D), Z in NewE..NewF.
\end{lstlisting}

The actual search for values of variables is handled by the 'search/0' and 'enum/1' rules. When 'enum/1' is fired with a variable that has a domain constraint ('X in A..B'), then it will cause X to take a value in its domain. Values are assigned to X by Prolog's 'between(A, B, X)' procedure. Each time X is assigned a value by this procedure, other rules may be fired, depending on what is in the constraint store at that time. Among those other rules could lie equality and adition constraints which can now further reduce domains of other variables because the domain of X has been removed. If this causes backtracking to happen back up to the 'between' procedure, the next value in the domain will be assigned to X.
\newpage
\begin{lstlisting}[ language = Prolog-pretty, caption  = {Search} ]
% assign values to variables X. X must lie between A and B
enum(X)            <=> number(X) | true.
enum(X), X in A..B <=> between(A, B, X).

% search for constraint variables
search, X in _.._ ==> var(X) | enum(X).
\end{lstlisting}

\subsection{Connectivity constraint}
The constraint that in the end result, the bridges must connect all islands into a single connected group, is handled in two different ways.

\subsubsection{Version 1}
The first version implements the connectivity constraint by checking whether or not all islands are reachable from a certain island. 'reachable/2' is used to represent which positions on the board are reachable. The reachable set can be expanded whenever a new bridge between two islands ('connection/2') is detected. The actual connectivity constraint is represented by lines 10 and 11 in the excerpt below. If, after the search phase is over, there is an 'island/3' fact without an accompanying 'reachable/2' fact, then the islands are not connected into a single group. This then causes backtracking to happen which causes search to try other values for variables.
\begin{lstlisting}[ language = Prolog-pretty, caption  = {Connectivity constraint propagator 1} ]
% put first island in reachable set
island(X, Y, _) \ pick_first_island <=> reachable(X, Y).

% build up reachable set
reachable(X, Y) \ connected([X, Y], [A, B]) <=> reachable(A, B).
reachable(X, Y) \ connected([A, B], [X, Y]) <=> reachable(A, B).
reachable(X, Y) \ reachable(X, Y) <=> true.

% connectivity constraint: each island fact needs to have an accompanying reachable fact
connected \ island(X, Y, _), reachable(X, Y)  <=> true.
connected, island(_, _, _)                    <=> false.
\end{lstlisting}

\subsubsection{Version 2}
The second connectivity constraint propagator follows a similar idea, but implements it by using a disjoint-set-like data structure. After the puzzle board is loaded, each island forms its own 'connected set' (or segment). A counter 'connected\_sets\_counter/1' represents the amount of connected sets that are on the board. 'connected\_set/3' represents which island belongs to which connected set. After a bridge has been formed between two islands ('connected/2'), their connected sets are merged together (lines 1, 4, and 10 below) by changing the identifier of the smaller connected set into the identifier of the larger one. After the sets have been merged, the 'connected\_sets\_counter/1' is decremented. The actual connectivity constraint is represented by the last line in the code excerpt. If, after the search phase is over, there exists more than one connected set, then the solution is not valid, and backtracking is forced. \\
Compared to version 1, this connectivity constraint propagator is actually worse. This is because it is more costly to keep track of all of the connected sets during search than to just check whether or not all island are reachable from a certain island. However, subsection \ref{sec:improvement2} contains an improvement for this version which makes it perform better than the previous one.

\begin{lstlisting}[ language = Prolog-pretty, caption  = {Connectivity constraint propagator 2} ]
connected_set(A, B, Set1), connected_set(C, D, Set2), connected_set_counter(Set1, Count1)
    \ connected([A, B], [C, D]), connected_set_counter(Set2, Count2)  <=> Set1 \== Set2, Count2 =< Count1 |
        connected_sets_union(Set1, Set2).
connected_set(A, B, Set1), connected_set(C, D, Set2), connected_set_counter(Set1, Count1)
    \ connected([C, D], [A, B]), connected_set_counter(Set2, Count2)  <=> Set1 \== Set2, Count2 =< Count1 |
        connected_sets_union(Set1, Set2).
connected_set(A, B, Set), connected_set(C, D, Set) \ connected([A, B], [C, D]) <=> true.
connected_set(A, B, Set), connected_set(C, D, Set) \ connected([C, D], [A, B]) <=> true.

connected_sets_union(Set1, Set2) \ connected_set(X, Y, Set2), connected_set_counter(Set1, Count) <=> NCount is Count + 1 |
    connected_set(X, Y, Set1),
    connected_set_counter(Set1, NCount).
connected_sets_union(_, _), connected_sets_counter(Count) <=> NCount is Count - 1 | connected_sets_counter(NCount).

connected, connected_sets_counter(C) ==> C > 1 | fail.
\end{lstlisting}

\subsection{Improvements}
\subsubsection{Improvement 1}
Our first improvement in the CHR solution follows the same logic as the first improvement in the ECLiPSe solution. Islands with value 1 cannot be connected to one another and islands with value 2 cannot be connected by 2 bridges (because then they would form isolated segments). This is not detected automatically by the domain solving rules of 'eq/2' and 'add/3', so we have added 4 rules which reduce the domains of variables before the search phase starts.

\begin{lstlisting}[ language = Prolog-pretty, caption  = {Connectivity constraint propagator 2} ]
% improvement A: island with 1 cannot be connected to other island with 1, so set variable to 0
make_domains, board(X1, Y1, 1, N, _, _, _), neighbors(X1, Y1, 'N', X2, Y2), island(X2, Y2, 1) \ N in _.._ <=> var(N) | N = 0.
make_domains, board(X1, Y1, 1, _, E, _, _), neighbors(X1, Y1, 'E', X2, Y2), island(X2, Y2, 1) \ E in _.._ <=> var(E) | E = 0.
% improvement B: 2 cannot be connected to 2 by 2 bridges, so make domain A..1
make_domains, board(X1, Y1, 2, N, _, _, _), neighbors(X1, Y1, 'N', X2, Y2), island(X2, Y2, 2) \ N in A..2 <=> var(N) | N in A..1.
make_domains, board(X1, Y1, 2, _, E, _, _), neighbors(X1, Y1, 'E', X2, Y2), island(X2, Y2, 2) \ E in A..2 <=> var(E) | E in A..1.
\end{lstlisting}

This improvement removes a lot of the guess work done by 'between/3', because the reduction of some of the domains can cause a domino effect to occur in which a lot of domains can subsequently be reduced. On some boards there isn't even a need for the search phase any more because the board can be solved by the domain solving of 'eq/2' and 'add/3'. \\
This improvement also has an impact on the connectivity constraint, as isolated sets like 1-1 and 2=2 cause the connectivity constraint to not be satisfied. This is particularly impactful for example on boards for which the solver would guess an isolated set like 1-1 right at the beginning of the search phase. In that case, backtracking would need to go over all choice points made after the variables included in the 1-1 set.

\subsubsection{Improvement 2}
\label{sec:improvement2}
The biggest flaw in the two connectivity constraint propagators was that checking the connectivity constraint only happens after a value has been assigned to all variables. The connected sets of the second connectivity constraint propagator allows us to detect isolated segments earlier during the search phase. First,  'no\_isolated\_segments/0' is added to the constraint store after a new value has been assigned to a variable. 'no\_isolated\_segments/0' is used to add 'connected\_set\_not\_isolated/1' into the constraint store. This then makes sure that each connected set currently on the board is not isolated. A connected set is not isolated when one of the islands in the set can still create a bridge (and this is possible when one of the directions in the 'board/7' is still a variable). If no such island is found in a set, then backtracking is forced (last line in the excerpt below).

\begin{lstlisting}[ language = Prolog-pretty, caption  = {Connectivity constraint propagator 2} ]
search, X in _.._ ==> var(X) | enum(X), no_isolated_segments.

...

no_isolated_segments, connected_set_counter(Set, _) ==> connected_set_not_isolated(Set).
no_isolated_segments <=> true.

connected_sets_counter(1) \ connected_set_not_isolated(_) <=> true.
connected_set(X, Y, Set1), board(X, Y, _, N, _, _, _) \ connected_set_not_isolated(Set1) <=> var(N) | true.
connected_set(X, Y, Set1), board(X, Y, _, _, E, _, _) \ connected_set_not_isolated(Set1) <=> var(E) | true.
connected_set(X, Y, Set1), board(X, Y, _, _, _, S, _) \ connected_set_not_isolated(Set1) <=> var(S) | true.
connected_set(X, Y, Set1), board(X, Y, _, _, _, _, W) \ connected_set_not_isolated(Set1) <=> var(W) | true.
connected_set_not_isolated(_) <=> false.
\end{lstlisting}

This improvement has a large impact on the connectivity constraint, because now the connectivity constraint is checked during the search phase instead of after the search phase. If an isolated segment were to be formed early in the search phase, this improvement would detect it and cause backtracking to happen instantly, whereas without this improvement backtracking would need to go over all choice points made after the creation of the isolated set. The effect of this improvement is most visible on board 2. Its solving time went from 516s with improvement 1 to 317s with improvement 1 and 2 (see tables in section \ref{sub:hashi-exp-2}). This improvement did not have a great impact on most other boards. This is because most other boards had smaller and fewer (or zero in some cases) domains to chose from during the search phase because of the domain solving done by 'eq/2' and 'add/3'.

\subsection{Experiments}
\label{sub:hashi-exp-2}
	\begin{figure}[h]
    	%\label{fig:improvement1}
        \centering
        \subfloat[board pre search]{{\includegraphics[width=2cm]{board_4_pre}}}%
        \qquad
        \subfloat[board post search]{{\includegraphics[width=2cm]{board_4_post} }}%
        \caption{Even for CHR some of the boards are completely filled in before the search (In this example: board 4)}%
    \end{figure}
\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|}
\hline
    board number & no improvements & isolation improvements\\
    \hline
        1   & 0.049s & 0.044s \\
        2   & aborted after 1h30m & 497.33s (8.3m) \\
        3   & 0.026s & 0.03s \\
        4   & 0.054s & 0.057s \\
        5   & 0.05s & 0.049s \\
        6   & 0.121s & 0.114s \\
        8   & 0.006s & 0.004s \\
        9   & 0.006s & 0.007s \\
        10  & 26.642s & 1.344s \\
        11  & 0.044s & 0.049s \\
        12  & 0.05s & 0.05s \\
        13  & 0.056s & 0.056s \\
        14  & 0.097s & 0.066s \\
        15  & 1.584s & 1.527s \\
        16  & 1.11s & 1.113s \\
        17  & 2.152s & 0.222s \\
        18  & 0.035s & 0.051s \\
        19  & 0.01s & 0.011s \\
        20  & 0.034s & 0.024s \\
        21  & 0.012s & 0.013s \\
        22  & 0.028s & 0.027s \\
    \hline
\end{tabular}
\caption{Improvements on CHR solver with connectivity propagator 1}
\end{table}

\begin{table}[h]
\centering
\begin{tabular}{|c|L|L|L|L|}
\hline
    board number & no improvements & isolation improvements & connectivity constraint improvement & all improvements\\
    \hline
        1   & 0.05s & 0.053s & 0.054s & 0.048s \\
        2   & unknown & 515.92 (8.6m) & unknown & 316.37s (5.3m) \\
        3   & 0.028s & 0.028s & 0.028s & 0.026s \\
        4   & 0.065s & 0.059s & 0.057s & 0.062s \\
        5   & 0.058s & 0.052s & 0.051s & 0.051s \\
        6   & 0.125s & 0.119s & 0.127s & 0.116s \\
        8   & 0.007s & 0.004s & 0.006s & 0.006s \\
        9   & 0.007s & 0.01s & 0.007s & 0.006s \\
        10  & 27.415s & 1.356s & 50.548s & 1.34s \\
        11  & 0.046s & 0.047s & 0.048s & 0.048s \\
        12  & 0.052s & 0.048s & 0.053s & 0.052s \\
        13  & 0.059s & 0.059s & 0.06s & 0.06s \\
        14  & 0.093s & 0.077s & 0.093s & 0.076s \\
        15  & 1.587s & 1.613s & 1.604s & 1.555s \\
        16  & 1.127s & 1.226s & 1.132s & 1.143s \\
        17  & 2.221s & 0.232s & 2.585s & 0.234s \\
        18  & 0.047s & 0.049s & 0.06s & 0.039s \\
        19  & 0.01s & 0.011s & 0.012s & 0.011s \\
        20  & 0.024s & 0.023s & 0.024s & 0.029s \\
        21  & 0.012s & 0.013s & 0.014s & 0.012s \\
        22  & 0.03s & 0.037s & 0.024s & 0.026s \\
    \hline
\end{tabular}
\caption{Improvements on CHR solver with connectivity propagator 2}
\end{table}

\mychapter{3}{Conclusion}

\section{Weak points}
There are a couple of weak points in our report:
\begin{itemize}
    \item The speed of our Sudoku implementations in CHR are not that great. We did try to improve it with the heuristics, but we feel it is still too slow. We think this was more due to the fact that we were still novices with how CHR worked as our Hashiwokakero CHR implementation is quite fast.
    \item The implementation of the connectivity constraint in ECLiPSe for Hashiwokakero is also a rather weak point. Ideally we should have implemented it using disjoint sets like in CHR but we couldn't figure out how to do this correctly.
    \item We think that implementing a Hashiwokakero solver using a graph representation is a more logical approach than the one we have used, but we had problems with ECLiPSe and how to express the no crossing bridges constraint.
\end{itemize}
\section{Strong points}
The strong points in our report are:
\begin{itemize}
    \item Our Hashiwokakero CHR implementation is quite fast thanks to our improvements set.
    \item We think we have good heuristics for Sudoku in CHR. Certainly the heuristic for the alternative viewpoint has made good improvements on the speed of the search.
\end{itemize}

\section{Lessons learned}
We have learned a lot of things during this project due to the fact we often had to re-track our steps. If we would now have to do an other project with these systems we think we would have a better idea for how to start and what to think about. We spent quite some time with both ECLiPSe and CHR so we now have a much better idea of what the strong points are and the weak points are for each system.

\mychapter{4}{Appendix}
We started working on this project before the Easter holiday. In the beginning we often lost quite some time, since we didn't really know how the systems worked. During the second week of the Easter holiday, we continued to work on the project each evening and we finished the Sudoku task and the ECLiPSe part of hashiwokakero before the end of the holiday. We then had to halt our work for a while since we had a deadline for a ridiculously large project for another course. As the semester was coming to an end other deadlines and an exam were coming up so we had to manage those first. Thus it was only at the start of the study period that we could continue working. From the start of the study period we tried to spend around 6 hours of work each day for this project. The work was not really divided since we were doing pair programming most of the time. Sometimes someone made individual changes when they had time but most of our work was done online using Hangouts and its screen sharing functionality. We could argue that by doing pair programming we lost quite some time, which is true, but by doing this we worked very closely together and we learned quite a lot. We have each individually put more than 100 hours in this project.
\end{document}
